
### 1）主要思想
   KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

### 2）什么是next数组

next数组就是一个前缀表（prefix table）

前缀表有什么作用呢？

**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

为了清楚地了解前缀表的来历，我们来举一个例子：

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

![[Pasted image 20241028204236.png]]

可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。

但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。

此时就要问了**前缀表是如何记录的呢？**

首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。

那么什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

### 3）为什么一定要用前缀表

这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？

回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图：
![[Pasted image 20241028205122.png]]
然后就找到了下标2，指向b，继续匹配：如图：
![[Pasted image 20241028205155.png]]

**下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**

### 4）求next数组--getNext( )

![[Pasted image 20241028205714.png]]
对于只包含第一个字符（下标为0的字符）的子串`a`，其最长相同前后缀的长度为0。（注意字符串的**前缀是指[不包含最后一个]字符的所有以第一个字符开头的连续子串**；**后缀是指不[包含第一个]字符的所有以最后一个字符结尾的连续子串**。）

![[Pasted image 20241028205733.png]]
长度为前2个字符的子串`aa`，最长相同前后缀的长度为1

长度为前3个字符的子串`aab`，最长相同前后缀的长度为0。

以此类推： 长度为前4个字符的子串`aaba`，最长相同前后缀的长度为1。 长度为前5个字符的子串`aabaa`，最长相同前后缀的长度为2。 长度为前6个字符的子串`aabaaf`，最长相同前后缀的长度为0。

那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：
![[Pasted image 20241028205806.png]]

可以看出模式串与前缀表对应位置的数字next\[i]表示的就是：
**next\[i]=下标i之前（包括i）的字符串中，相同前缀后缀的长度**

再来看一下如何利用前缀表，找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：

![[Pasted image 20241028210016.png]]
当比较到如图所示的位置时，发现出现了不匹配的情况：$b≠f$，于是需要把**下面的箭头**倒退回去（不是倒退上面的）

![[Pasted image 20241028210035.png]]
而此时失配位置f的前一位的next值为2，说明在失配位置f之前的、下标从0到i-1（假设f的下标为i）的这个字串 的最长公共前后缀的长度就是2（即next\[i-1]=2）

那么这意味着什么呢？意味着在 当前失配的元素  的前面，有2个元素，它们作为一个后缀，和模式串的前2个元素是"对称"的（这种对称是诸如"abcabc"的，而不是如"abccba"），而失配位置是当前位置，说明 \[文本串（母串）的当前失配元素的前面两个元素] 和 \[模式串的当前失配元素的前面2个元素] 是相同的，所以这[3]者是[相同]的关系

![[Pasted image 20241028211225.png]]
**a) next\[i-1]=2 说明①和②是相同的；
b) 文本串和模式串能一直匹配到f之前，这又说明②和③是相同的，所以这三个子串全都相同；**

**所以，现在我们知道了①=③，那么就无需把下面的箭头一直倒退回至下标为0的位置（即模式串的开头）了，因为我们已经确定了模式串的前两位元素（下标为0、1的元素）和上面箭头的前两个元素相同，那么就直接把下面的箭头移到①的后继元素、比较这个元素和b是否相同就可以了**


> [!NOTE] Title
> 主要是通过next\[i-1]得知①=②、再根据②=③，得到①=③！
>  而②其实是起到一个桥梁的作用


![[Pasted image 20241028210049.png]]

![[Pasted image 20241028210137.png]]

```cpp
//求next数组的函数
void getNext(int* next, const string& s) {//注意参数和函数类型是什么
        
        //初始化
        int j = 0;//当i,j=0时,串只包含第一个元素(下标0),next[0]肯定是0
        next[0] = 0;//next[0]肯定是0

        for(int i = 1; i < s.size(); i++) {//从第二个元素(下标为1)开始遍历
            while (j > 0 && s[i] != s[j]) {//如果不相等,把j回溯
                j = next[j - 1];//这里是"j-1"而不是"i-1"!!
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;// 将j（前缀的长度）赋给next[i]
        }
    }

```

### 5）getNext( )代码解释

##### **j有双重含义：**
- 作为一个**下标**，若存在公共前后缀，则j指向前缀的最后一个元素；
	
- 因为前缀是从第一个元素s\[0]开始的，所以前缀的尾元素的下标**j**，就刚好等于**前缀的长度**，因此也是**公共前后缀的共同长度**；
	
- 若j=0，则说明不存在公共前后缀

##### **这里是==j-1==而不是"i-1"！！**
```cpp
while (j > 0 && s[i] != s[j]) {//如果不相等,把j回溯
            j = next[j - 1];//这里是"j-1"而不是"i-1"!!
        }
```

##### **代码的执行一共有以下这几种可能**
- **（一）next\[i-1]=0**
	这说明在第i个元素（这里不特地点明是模式串，因为next数组就是针对模式串s求的，不关母串的事）之前的那个子串（`s\[0]~s\[i-1]`）不存在公共前后缀，故此时j=0（即不存在公共前后缀），所以`s[i]==s[j]`是比较s\[i]和模式串的第一个元素s\[0]。
	
	所以又分两种情况：
		**（1）s\[i]=s\[j]**
		如果相等，则`j++`，代表公共前后缀的长度变成了1；
		**（2）s\[i]≠s\[j]**
		如果不等，则j不变，仍为0，故next\[i]=j=0；

- **（二）next\[i-1]≠0**
	这说明前面的子串（`s\[0]~s\[i-1]`）存在**公共前后缀**，且**长度应为 `j`**（在对i的每轮递增循环的开始，`j`的值还是等于`next\[i-1]`的，因为每次循环的末尾都会执行一句`next[i] = j`），且此时`j`已经通过上一轮的`j++`指向了 **最长前缀的尾元素 的下一个元素**（这是因为`j`=公共前后缀的长度=最长前缀的长度，又因数组下标从0开始）；
	
	所以又分两种情况：
		**（1）s\[i]=s\[j]**
		如果相等，则公共前后缀的长度又＋1，即`j++`；然后置当前的`next[i]=j`即可
		**（2）s\[i]≠s\[j]**
		如果不相等，那么把`j`回溯为==next[j-1]==，后者是s串的第`j`个元素的next数组值，即s串的第`1`到第`j`个元素组成的子串的公共前后缀长度。这又分两种情况：
			**a. next\[j-1]=0**
			说明连s\[j-1]和s\[0]都不相等，那么即使`s[i] = s[j]`也没什么用，所以在`while`循环条件里加了一个`j>0`；
			**b. next\[j-1]≠0**
			说明至少有`s[j-1]=s[0]`，而若又有`s[i] = s[j]`（在下一轮循环的循环条件里），所以就传递性地得到`s[i]=s[0]`；而且由于要知道，说明`s[i]`前面的元素和`s[j]`前面的元素都是匹配的，所以`s[0]~s[j-1]`和`s[j]~s[i]`这两个前后缀子串就是对称的，那么就可以跳出`while`，

*### 补充：[一篇较易懂的文章](https://blog.csdn.net/yearn520/article/details/6729426)

### 6）KMP主函数

```cpp
int KMP(string s, string t)
{
    int n = s.length(), m = t.length();
    int* next = new int[m];
    getNext(t, next);  // 求出局部匹配信息数组 next
    int i = 0, j = 0;
    while (i < n && j < m)  // s 和 t 均没有遍历完
    {
        if (j == -1 || s[i] == t[j])  // j == -1 或者比较的字符相同时
        {
            i++;
            j++;  // i, j 各增 1
        }
        else
        {
            j = next[j];  // 否则 i 不变, j 回退
        }
    }
    delete[] next;  // 释放动态分配的内存
    if (j >= m)
        return i - m;  // t 串遍历完毕: 匹配成功
    else
        return -1;  // 匹配不成功, 返回 -1
}

```

通常，指令执行有五个阶段，但我们在lec18中所讨论的R型和I型指令不涉及内存访问，所以省略了内存访问阶段。

为了支持加载和存储指令，我们需要引入数据内存。RISC-V是一种加载/存储架构，所有与内存的操作仅限于加载和存储指令。

以`lw`加载字指令为例，它也是I型格式，具有12位符号扩展的立即数。该立即数与`rs1`寄存器中的值相加，结果作为内存地址，然后将该地址处的数据写回到目标寄存器。

加载指令的数据通路与I型指令的结构大致相同，**区别在于引入了内存**。我们通过**多路复用器选择写回的数据来源 是来自ALU还是内存**。**新增控制信号`写回选择`用于确定数据来源**。内存被视为一个组合逻辑块，读写控制设为“读”。

加载指令的执行步骤：

1. 程序计数器指向**指令存储器**并获取指令。
2. 解码指令，设置信号控制，并处理立即数。
3. **ALU将`rs1`中的值与立即数相加，得到内存地址。**
4. 进行内存访问。
5. 将内存中的数据写回到目标寄存器。


![[Pasted image 20240909162618.png]]


## Processor是如何区别对待不同的load指令的

在RISC-V架构中，处理器通过指令的 **功能码（funct3字段）** 来区分不同的加载指令
### 1. **指令解码**：

- 在数据通路中，指令被从指令存储器（IMEM）中提取后，解码逻辑会解析指令中的各个字段，尤其是功能码`funct3`。
- `funct3`字段用于区分`lb`、`lh`、`lw`等不同加载指令。**解码单元根据`funct3`字段的值，生成不同的控制信号来指定加载的数据宽度和是否需要符号扩展。**

### 2. **控制逻辑生成控制信号**：

- **控制信号生成**：解码指令后，控制逻辑会生成不同的控制信号，指示要执行哪种类型的加载操作。
- 例如：
    - 对于`lb`，控制信号指示加载1个字节，并**执行符号扩展**。
    - 对于`lh`，控制信号指示加载2个字节，并**执行符号扩展**。
    - 对于`lw`，控制信号指示加载4个字节，并**直接写入寄存器**。

### 3. **数据内存访问（DMEM）**：

- 根据ALU计算出的内存地址，数据内存（DMEM）会被访问。
- 数据从内存中取出后，由**数据扩展逻辑**决定如何处理这些数据：
    - 如果是`lb`指令，数据内存**只会读取一个字节**，数据扩展逻辑会将这个字节符号扩展为32位（带符号扩展）。
    - 如果是`lh`指令，**读取2个字节，并对其进行符号扩展。**
    - 如果是`lw`指令，**读取完整的32位字，无需扩展。**

### 4. **写回寄存器**：

- 读取的数据经过数据扩展处理后，通过多路复用器选择路径，将扩展后的数据写回到目标寄存器。

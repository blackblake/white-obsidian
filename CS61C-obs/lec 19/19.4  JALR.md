到目前为止，我们已经构建了支持R型、I型、S型和B型指令的数据通路及相关控制。在这个过程中，我们已经几乎添加了所有硬件，来支持指令集中的其余指令。要支持剩余指令，只需做一些相对较小的修改。接下来，我们来看一下如何添加对JALR指令的支持。JALR指令代表“跳转并链接寄存器”，通常用于函数调用。

**JALR指令属于I型格式，与之前的算术指令和加载指令使用相同的格式**。在这种格式中，高12位为立即数，此外还有一个源寄存器和一个目标寄存器。指令的格式为：JALR rd, rs, immediate。

JALR指令对状态有两项修改：**首先，将PC+4的值写入目标寄存器，这将作为函数调用的返回地址；然后跳转到由rs1加上立即数指定的函数地址。**

请注意，JALR的立即数格式做了一个折中处理。由于立即数的最低位总是设置为0，我们丢失了一位范围，因此JALR的跳转范围稍有减少。但这简化了数据通路，我们复用了I型指令的立即数生成机制。

![[Pasted image 20240909173623.png]]

要支持JALR，我们需要做的修改是：
- **添加一条通路，允许我们将PC+4的值写入目标寄存器**。我们通过扩展回写选择多路复用器来实现这一点，使其有三个可能的输入：一个从数据存储器回写，一个从ALU回写，另一个是PC+4的值。我们本可以采用其他方式，例如在串联中添加一个多路复用器，但这样做更简单。通过扩展多路复用器，回写选择现在有三个值：0、1和2。

- **其余的修改通过控制单元完成。数据通路没有其他变化，我们只需要正确设置控制位。** 需要注意的是，PC的选择控制信号始终设置为“取分支”，因为JALR是跳转指令。立即数选择为I型，因为JALR与I型指令格式相同。我们启用了寄存器文件的写入，因为需要将返回地址写入目标寄存器。忽略与分支相关的信号，适当地设置ALU的输入多路复用器，并将ALU设置为执行加法操作。由于我们不操作数据存储器，因此将其设置为默认的读状态。回写选择则设为2，如前所述。


现在我们来看一下JALR的数据通路：

当获取指令后，我们立即开始解码。**需要注意的是，我们没有将PC+4的值返回到程序计数器的输入中，而是将其传递给回写选择多路复用器。** 控制逻辑适当地设置各个信号后，立即数生成与rs1的值将同时传递到ALU中，rs2将被忽略，因为它在指令字段中无效。ALU的输出是rs1的值与立即数相加的结果，该结果将传递给PC选择多路复用器，后者始终选择该值作为程序计数器的输入，而不是PC+4。

与此同时，回写选择多路复用器将PC+4传递到目标寄存器的输入。下一时钟周期时，这两个状态都会被更新。这样，JALR的执行就完成了。

![[Pasted image 20240909173819.png]]

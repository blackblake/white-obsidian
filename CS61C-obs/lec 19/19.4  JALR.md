**JALR指令属于I型格式，与之前的算术指令和加载指令使用相同的格式**。在这种格式中，高12位为立即数，此外还有一个源寄存器和一个目标寄存器。

JALR指令对状态有两项修改：**首先，将PC+4的值写入目标寄存器，这将作为函数调用的返回地址；然后跳转到由rs1加上立即数指定的函数地址。**

请注意，JALR的立即数格式做了一个折中处理。由于立即数的最低位总是设置为0，我们丢失了一位范围，因此JALR的跳转范围稍有减少。但这简化了数据通路，我们复用了I型指令的立即数生成机制。

![[Pasted image 20240909173623.png]]

要支持JALR，我们需要做的修改是：
- **添加一条通路，允许我们将PC+4的值写入目标寄存器**。我们通过扩展回写选择多路复用器来实现这一点，使其有三个可能的输入：一个从数据存储器回写，一个从ALU回写，另一个是PC+4的值。我们本可以采用其他方式，例如在串联中添加一个多路复用器，但这样做更简单。通过扩展多路复用器，回写选择现在有三个值：0、1和2。

> [!NOTE] **ImmSel的机制——MUX**
> 通过多个多路选择器`MUX`，`ImmSel`可以从指令中  **提取相应的字段(因为不同类型指令的立即数所在的字段不同)**  来生成不同类型的立即数。
> 而`ImmGen` 单元负责根据指令的类型和 `ImmSel` 信号的控制，提取指令中的特定位段并对其进行`符号扩展`，生成相应的立即数。


- **其余的修改通过控制单元完成。数据通路没有其他变化，我们只需要正确设置控制位。** 需要注意的是，PC的选择控制信号始终设置为“取分支”，因为JALR是跳转指令。立即数选择为I型，因为JALR与I型指令格式相同。我们启用了寄存器文件的写入，因为需要将返回地址写入目标寄存器。忽略与分支相关的信号，适当地设置ALU的输入多路复用器，并将ALU设置为执行加法操作。由于我们不操作数据存储器，因此将其设置为默认的读状态。回写选择则设为2，如前所述。


现在我们来看一下JALR的数据通路：

当获取指令后，我们立即开始解码。**需要注意的是，我们没有将PC+4的值返回到程序计数器的输入中，而是将其传递给【回写选择多路复用器】**。ImmGen与rs1的值将同时传递到ALU中，输出rs1的值与立即数相加的结果，并将结果传递给PC选择多路复用器，后者始终选择该值作为程序计数器的输入，而不是PC+4。

与此同时，回写选择多路复用器将PC+4传递到目标寄存器的输入。下一时钟周期时，这两个状态都会被更新。这样，JALR的执行就完成了。

![[Pasted image 20240909173819.png]]

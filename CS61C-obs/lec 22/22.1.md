
我们设计了功能齐全的RISC-V处理器，这是个很大的成就。但我得告诉你一个秘密，实际上没有人使用单周期CPU。早期确实有一些单周期CPU，但它们基本上已经被淘汰了。为什么呢？因为它们通常效率不高。并不是每条指令都会使用每个阶段，单周期CPU的周期必须涵盖所有五个处理阶段。所以人们做了什么呢？他们采用了流水线化，而这与我们之前看到的洗衣流程非常相似。

在洗衣过程中，我们看到有四个处理阶段——洗衣、烘干、折叠、收纳。当有多个人需要做洗衣任务时，没有人会等到所有步骤都完成后才开始下一件衣物的处理。通常我们会在第一件衣物洗完后立即将另一件放进洗衣机，之后按照我们之前看到的流程继续下去。

在处理器中也是一样。就像洗衣处理一样，数据处理在处理器中也分为五个阶段——指令获取、指令解码和寄存器读取、执行阶段、内存访问和写回。在我们的例子中，我们为每个阶段设置了一些合理的时间代表。我们说指令获取阶段耗时200皮秒，寄存器读取耗时100皮秒，ALU（算术逻辑单元）耗时200皮秒，内存访问耗时200皮秒，最后寄存器写回耗时与寄存器读取相同，大约是100皮秒。**注意，寄存器读取和寄存器写回的时间比其他阶段短，这是有意义的**，我们稍后会回到这个点。

**因此，执行整条指令的时间就是所有这些阶段的时间总和，而这就是800皮秒。** 我们这里还用了一个示意图，这个图可以在我们的教科书和其他一些教科书中找到，用来说明每个阶段的活跃状态。当表示内存的方框只有一半被阴影覆盖，且阴影在右侧时，表示我们在读取内存。同样，当我们从寄存器读取时，我们也会在右侧着色。相反，当我们要写入内存时，我们会将方框的左侧着色，寄存器写回阶段也是如此。当ALU处于活跃状态时，我们会将整个方框着色。

让我们看看单周期CPU是如何处理数据的。这里有一组我们要处理的指令序列。假设我们首先遇到一条“add”指令，在单周期中，我们将通过所有五个阶段处理它。我们获取指令、解码它、访问寄存器，执行在解码过程中识别的加法操作。我们不需要对内存做任何操作，但我们仍然会等待这段时间过去。最后，我们写回结果。当这一切都完成后，我们才会开始执行下一条指令，即“or”。当“or”写回结果时，我们再开始第三条指令“逻辑左移”。

这就像我们在洗衣示例中看到的那样，是浪费的。所以我们可以做得更好。我们怎么做得更好呢？我们采用流水线化。**我们不需要等待整条指令完成后才开始下一条指令。我们只需要等第一个资源空闲，也就是指令内存。一旦我们完成了从指令内存读取“add”指令，即使我们还不知道它是“add”，我们只读取了32位数据，我们就可以开始读取下一条指令“or”。** 因此，在解码“add”指令的同时，我们可以获取“or”指令。当我们完成读取“or”指令时，我们可以继续处理第三条指令“逻辑左移”。

因此，在读取“逻辑左移”时，我们实际上还在为“or”指令访问寄存器，并为第一条“add”指令执行加法操作。

注意，这里发生了一件事。**我们必须在这些阶段之间引入寄存器，也就是所谓的流水线寄存器，否则所有数据会混在一起。因此，我们看到这些指令是并发处理的，每条指令处于不同的执行阶段。** 

我们的时钟周期用于在这些执行阶段之间传输数据，它不再与整条指令的处理关联。因此，这个时钟周期变得更短了，只有处理整条指令时间的五分之一。我们稍后会看到更多细节。

**与单周期CPU相比，现在处理整条指令的时间变长了。原因是我们必须将时钟周期设置为匹配流水线中最慢的阶段。这意味着什么呢？这意味着流水线中的某些阶段需要200皮秒，而某些只需要100皮秒。由于我们使用同一个时钟来为所有阶段计时，我们必须将时钟周期设置为200皮秒，否则某些阶段无法完成它们的操作。因此，流水线处理器的T周期是200皮秒，这比单周期CPU的800皮秒短了很多。然而，执行整条指令的时间是1000皮秒，变长了。因此，我们在单指令的延迟上有所损失，但我们在吞吐量上大大提高了（就像把跑车变成卡车)）。** 

接下来我们来对比单周期处理器与流水线处理器的指令执行。

大多数内容是显而易见的，正如我们已经注意到的那样。**单周期CPU的每个阶段时间不固定，而在流水线中，所有阶段的时间都是固定的。** CPI（每条指令的周期数）理想情况下为1，但如果发生内存缺失，根据内存系统的性能，我们可能需要多于一个周期来处理一条指令。

而 **流水线系统可以使CPI降到1以下** ，虽然这不是这门课的重点（这是CS 152的内容）。我们已经看到，单周期CPU的时钟频率是1/800皮秒，即1.25GHz，而流水线处理器的时钟频率是5GHz，可以实现4倍加速。

##### *总之，单条指令的执行时间变长了，但由于时钟速度的大幅提升，我们的吞吐量有了显著提升。

注意，吞吐量的增加并不等于我们有的阶段数。理论上，我们可以得到5倍的吞吐量提升，但由于各阶段的延迟不平衡，我们损失了一些效率，不过我们仍然得到了4倍的提升。

这就是为什么人们总是设计流水线处理器的原因。正如我们将看到的，设计过程并不复杂得多，所以为何不采用呢？

让我们看一下顺序执行和同时执行时的情况。我们有六条指令，颜色说明了“add”指令不访问内存，“or”指令不访问数据内存，“逻辑左移”也不访问内存。但“存储字”指令写入内存，因此左侧被着色。“加载字”指令从内存中读取，因此右侧被着色。“立即数加法”不访问内存。

每条指令的执行时间为1000皮秒，周期时间是其中的五分之一，即200皮秒。现在，当我们想知道流水线中的资源使用情况时，每条指令都顺序经过获取、解码和寄存器访问、执行、内存访问和写回阶段。另一方面，多条指令同时使用不同的资源，因为这些资源是可用的。

我们可以看到五条“在途”的指令在使用不同的资源。这些资源在流水线中的使用情况如下：第一条指令即将完成，因此“add”指令正在将结果写回到寄存器`t0`。“or”指令处于数据访问阶段，实际上它并没有做任何操作，只是在等待“add”指令完成写回结果到寄存器`t3`。“逻辑左移”指令正在使用ALU执行移位操作。“存储字”指令正在从寄存器`t3`和`t0`中获取值，以便用于存储操作。而“加载字”指令则刚刚从内存中获取，虽然我们还不知道它是一条加载指令。

到目前为止，这就是我们需要知道的RISC-V处理器流水线的基本概念。它与运行洗衣流程非常相似。在接下来的模块中，我们将会探讨如何对数据路径进行调整以支持流水线化操作。
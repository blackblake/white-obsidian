
我们继续讨论**冒险（hazards）** 问题。我们已经确定了三种冒险类型：结构冒险、数据冒险和控制冒险。之前讨论了结构冒险，它通常通过数据路径的设计来解决，确保指令集架构（ISA）能够支持高效的流水线。接下来我们要讨论的是**数据冒险**，让我们先理解什么是数据冒险，然后再探讨如何应对它们。

### 1. **数据冒险的原因**
   数据冒险发生在指令之间存在数据依赖时。例如，某条指令（如 `add`）将计算结果写入寄存器（例如寄存器 `t0`），而紧接着的另一条指令（如 `store word`）希望读取相同的寄存器 `t0`。此时，`add` 指令会在写回阶段更新寄存器 `t0`，而 `store word` 在解码阶段试图读取寄存器 `t0`。问题是，如果 `store word` 在 `add` 指令写回完成之前读取了旧的值，则会发生数据冒险。

### 2. **避免数据冒险的硬件设计**
   为了解决这个问题，寄存器文件的设计支持**单周期读写操作**。这意味着，在一个时钟周期内，`add` 指令会在 **周期的前半部分** 完成写入寄存器，而 `store word` 在 **周期的后半部分** 可以读取更新后的值。这样，就避免了数据冒险。

### 3. **更复杂的数据冒险**
   当多个指令依赖同一个寄存器的值时，情况变得复杂。例如，`add` 指令将值写入寄存器 `s0`，随后几条指令（如 `sub`, `or`, `xor`, `store word`）都依赖 `s0` 的结果。如果 `add` 尚未完成写回操作，而下一条指令尝试读取 `s0`，则会得到旧值，导致错误的执行。

### 4. **解决方法：停顿和转发**

   - **停顿（Stalling）**：最直接的解决办法是插入“气泡”（**空指令**），延迟后续指令的执行，直到前面的指令完成写回。这虽然保证了正确性，但会**降低性能** 
   
   - **数据转发（Forwarding/Bypassing）**：更优化的硬件方法是**数据转发**：
	   1.原理：**在执行阶段，ALU 的输出结果是正确的，但尚未写入寄存器。我们可以通过硬件设计，将 ALU 的输出直接转发给下一条指令的输入端，避免等待寄存器写回。** 
	   2.硬件：这需要在数据路径中**增加额外的多路复用器和控制逻辑**，**比较当前指令和后续指令的目的寄存器，确定是否需要转发数据。**

### 5. **流水线中的数据转发设计**
   在流水线的数据路径中，添加数据转发路径允许将 ALU 的输出直接“绕过”寄存器文件，提供给后续指令的 ALU 输入。这些转发路径连接 ALU 输出和 ALU 输入，并通过多路复用器控制，确保在需要时进行正确的数据转发。

### 6. **总结**
   数据冒险通过硬件设计（如寄存器的单周期读写、数据转发）以及编译器优化（如重新安排指令顺序）来避免或减少性能损失。数据转发特别有效，它能够将数据从流水线的早期阶段直接传递到后续指令，避免停顿，提高流水线的执行效率。
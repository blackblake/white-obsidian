
到目前为止，我们已经将单周期CPU改造成了流水线处理器。在这个过程中，我们添加了一些流水线寄存器，并调整了一些资源的位置，使设计起来更简单。不过，我们还没有设计出一个好的流水线处理器，因为它在某些常见问题上遭遇了严重的流水线冒险（hazards）。

流水线冒险是指流水线处理器中遇到的一系列问题。与单周期处理器不同，流水线处理器同时有多条指令在执行，而单周期处理器中的每条指令都是独立的，一条指令完成后，下一条指令才开始执行，因此没有指令之间的依赖关系。但在流水线处理器中，如果某条指令的结果影响到下一条指令，那么就会出现问题，后续的指令无法继续执行。

通常有三种类型的冒险问题，因此我们需要理解它们，因为它们需要不同的解决方案来避免。冒险问题之所以称为“hazards”，是因为在早期阶段，谁应该负责解决这些问题并不明确。它们可以由编译器或流水线处理器的设计者来解决，但如果没有人处理这些问题，处理器可能会无法正常工作，甚至更糟糕的是，大部分时间它看似正常工作，但偶尔会发生故障，这类问题非常难以定位和解决。

正如我所说，我们可能遇到的冒险问题有三种类型：***结构冒险（structural hazards）、数据冒险（data hazards）和控制冒险（control hazards）***。

**这些冒险问题通常会阻止新指令的开始，因为流水线中有其他指令正在执行。** 

---

### 1#  结构冒险

**结构冒险是由于资源竞争而产生的。** 在大多数现代处理器中，至少像我们在本课程中设计的那样简单的处理器，通常不会遇到结构冒险，因为流水线是专门设计来匹配指令集架构（ISA）的，ISA本身避免了这些问题的产生。

最简单的结构冒险是我们在设计单周期CPU时就已经解决的问题，那就是程序计数器（PC）的递增与执行算术运算时内存访问的竞争。例如，我们本可以犯一个错误，即没有使用专门的`PC + 4`加法器，而是使用ALU来完成这个操作。如果每次我们都需要用ALU来计算`PC + 4`，那么ALU在执行指令时就无法使用。这意味着我们每次都需要在一个周期中先加上`PC + 4`，然后再执行指令。

因此，设计一个专用的`PC + 4`加法器是一个自然的选择。一般来说，结构冒险是因为流水线中的两条指令同时争用相同的资源造成的。解决结构冒险的两种方法之一是引入停顿（stall），就像我刚才描述的那样，下一条指令会等待，直到前一条指令用完资源。另一种常见的解决方案是增加更多的硬件，使所有指令能够并发执行。

让我们来看一个可能出现的结构冒险的例子，即 **寄存器文件的争用** 。在RISC-V的指令集中，指令可以访问寄存器文件三次：有两个操作数要读取，一个操作数要写入。因此，寄存器文件必须能够支持这种操作，否则会出现资源不足的情况。因此，我们设计的寄存器文件有两个读端口和一个写端口。记住，有三个地址输入到寄存器文件中。

这里还有一个细节，为了能够在一个周期内完成所有操作，我们假设寄存器文件的速度非常快，比处理器中的其他单元快。我们可以在100皮秒内读取寄存器文件，也可以在100皮秒内写入寄存器文件。这样就能在一个周期内同时读取和写入寄存器文件。不过 **关键在于，寄存器文件必须支持每周期三次并发访问** 。

再来看另一种结构冒险，即 **内存的竞争** 。在几乎所有指令中，我们都需要访问指令内存，但某些指令还需要读或写数据内存。我们之前讨论过统一内存概念，即我们使用存储程序计算机架构，意味着只有一个内存。因此每当有加载或存储指令时，它们会与其他指令争夺内存访问。

这里的例子显示，如果在内存访问阶段有一条`load word`指令，而同时有一条`add immediate`指令需要读取指令，那么如果只有一个内存，`add immediate`指令就 **必须等待，直到`load word`完成** 。解决这个问题的方法是**引入两个内存单元。** 

你可能会说，这不是自相矛盾吗？**我们之前说只有一个内存，怎么会有两个内存呢？其实，主内存确实只有一个，它位于DRAM中，但通常处理器芯片上有缓存（cache），它包含了从主内存复制过来的指令和数据，并提供了两种独立的访问方式。因此，在一条指令读取指令的同时，另一条指令可以完成数据的读写操作。** 

总之，结构冒险确实存在，但通常通过硬件设计来避免，确保硬件匹配指令集架构（ISA）。我们确保硬件能够支持所有指令在流水线的不同阶段中并发执行。例如，寄存器文件必须支持ISA要求的访问次数，并且我们需要分离指令和数据内存，或者至少提供内存的副本，使其能够独立访问。

---
### 2#  数据冒险

**数据冒险是由于指令之间的依赖性引起的。** **例如，如果一条指令正在流水线中执行，并且它要将结果写入寄存器文件，而下一条指令需要依赖这个结果，那么这条指令在结果写回之前不能继续执行，否则会使用到不正确的值。** 

---
### 3#  控制冒险

**控制冒险发生在分支指令存在时。如果流水线中有一个分支指令，紧随其后的一条指令可能是无效的，因为如果分支被执行了，那么这条指令就不应该被执行。**


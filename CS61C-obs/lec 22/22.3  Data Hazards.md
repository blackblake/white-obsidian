
之前我们讨论了流水线是如何应用到洗衣处理中的，还概述了如何对RISC-V数据路径进行流水线化。我得出的结论是，如果我们要构建一个五阶段的流水线处理器，应该将执行过程分为五个阶段：指令获取（instruction fetch）、指令解码（instruction decode）、执行（execute）、内存访问（memory access）和写回（write back）。

现在我们来看一下我们已经非常熟悉的单周期数据路径，并看看应该如何对其进行流水线化。这里是我们的单周期数据路径，里面有我们之前见过的熟悉模块，比如程序计数器、指令存储器、这个`PC + 4`加法器、立即数生成器、寄存器文件、分支比较器、ALU、数据存储器以及配置这个数据路径以执行特定指令的多路复用器。当然，还有控制逻辑来配置这个数据路径。我们还概述了这个数据路径中的不同执行阶段，这些阶段将被分解为不同的流水线阶段。简而言之，这些阶段分别是指令获取、指令解码与寄存器读取、ALU执行阶段、内存访问和写回阶段。

**指令获取阶段** 在时钟的上升沿开始，通过递增程序计数器，并通过指令存储器读取数据完成。**记住，我们将[内存读取]和[寄存器访问]视为[组合逻辑操作]，这意味着它们不依赖于时钟。只要数据在输出端稳定，我们就假设操作已经完成。因此，一旦指令位在指令存储器的输出端稳定，我们就进入下一阶段。** 

下一阶段是 **指令解码阶段** ，在这一阶段我们解码指令并读取寄存器。寄存器的读取也像组合逻辑一样进行，所以 **一旦寄存器文件的输出值稳定，指令解码阶段就完成了。** 

然后我们进入 **执行阶段** ，执行ALU运算。ALU的输出一旦有效，我们就进入内存访问阶段，如果我们正在进行加载或存储操作的话。完成这些操作后，我们进入写回阶段，**在时钟的上升沿将结果写回目标寄存器。**

那么，我们该如何实现流水线呢？很简单，我们只需在适当的位置插入寄存器。**在每个执行阶段的边界，我们都需要放置寄存器。** 因此，我们将在这里插入寄存器，并分别标记为IF/ID、ID/EX、EX/MA和MA/WB，以分隔各个执行阶段。

让我们看看其中的一些重点，虽然看起来相对熟悉。**首先，在指令获取阶段结束时，我们有两个寄存器，一个用于保存程序计数器，另一个用于保存指令。 后者特别有趣，请记住，我们同时有五条指令在执行。当其中一条正在被获取时，前面获取的指令已经进入流水线的下游，所以我们需要保存这些指令。** 

**每个流水线寄存器都必须保存与当前阶段执行的指令相关的位，否则我们将无法知道该阶段正在执行什么。因此，该阶段不仅需要保存指令，还需要保存与之对应的控制位。** 

另一个值得注意的点是，我们将程序计数器值传递下去，并在流水线中进行传递，但 **我们没有传递`PC + 4`的值，而是在内存访问阶段重新生成`PC + 4`的值。这是一个设计决定，它比使用1、2、3个寄存器来存储三个32位的`PC + 4`值更便宜。**

我们还注意到，程序计数器值在前面的三个执行阶段中使用得更多，而我们只在内存访问阶段需要`PC + 4`值，以便将其写回（如果需要）。大体上，这一切看起来都相对简单，虽然还有一些稍后我们会看到的复杂点。

另一个我想强调的地方是，实际上我们同时有五条指令在流水线上，最后一条是在写回阶段。最早进入流水线的指令是"or"指令，它现在已经进入内存访问阶段。然后是稍微晚一点的"slt"指令，再然后是"store word"指令。当前被获取的指令是"load word"。 **请记住，我们必须将与每条指令相关的所有内容都打包到流水线阶段中。因此，在内存访问阶段的指令将会有它的副本保存在寄存器中，并且与之对应的值也会保存在该阶段之前的寄存器中。同样的情况也适用于执行阶段，在执行阶段之前，我们保存的是当前执行的"store word"指令所需的所有内容，因为下一条指令将获得新的值。** 

---
### 解释
##### 1. 指令的副本保存在流水线寄存器里

每当指令通过一个执行阶段时，它的副本会保存在两个相邻执行阶段之间的流水线寄存器里。这些流水线寄存器负责在不同的阶段之间传递信息，确保每个阶段在处理指令时有所需的数据和控制信号。

##### 2. **流水线寄存器的位置**

`流水线寄存器被插入在每个阶段的边界上`，具体来说有以下几个寄存器：

- **IF/ID**：指令获取和指令解码之间
- **ID/EX**：指令解码和执行之间
- **EX/MA**：执行和内存访问之间
- **MA/WB**：内存访问和写回之间

比如当指令在指令获取阶段（Instruction Fetch, IF）结束时，相关信息会被保存到IF/ID流水线寄存器中，之后传递给下一阶段的指令解码。

##### 3. **保存后，后续阶段如何使用这些副本？**

指令的副本以及其相关的控制信号会被保存并在流水线中向后传输。例如：

- 在内存访问阶段，保存的副本包含了指令的操作数、目标寄存器地址等。这些信息将会在写回阶段使用。
- 在执行阶段，ALU运算可能会产生结果，而这个结果会存储在流水线寄存器中，然后被传递到内存访问和写回阶段。

##### 4. **副本信息如何向后传输？**

每个流水线寄存器将当前阶段的所有相关信息，包括指令位、数据以及控制信号传递给下一个流水线阶段。例如：

- 在指令解码阶段（ID）之后，ID/EX寄存器将指令解码后的操作数、控制信号等传递给执行阶段。
- 执行阶段结束时，EX/MA寄存器将ALU运算结果、控制信号传递给内存访问阶段。

通过这种方式，信息在流水线中逐步向后传输，确保每个阶段能够独立执行，避免阶段之间的相互依赖。


---


**除了指令位以外，我们还需要保存解码后的控制位。记住，控制逻辑告诉我们每个阶段应该执行什么任务，如何配置每个阶段。因此，当我们解码指令后，除了指令本身之外，还需要将与指令相关的所有控制位一起传递下去。因此，保存程序计数器的每个寄存器将会稍微宽一些，以保存必要的控制信号。** 

举个例子，内存访问阶段的寄存器，或者介于内存访问和写回之间的寄存器，必须保存与最终写回操作相关的控制信号。而在执行阶段和内存访问阶段之间，我们需要保存与内存访问和写回阶段相关的位，依此类推。这基本上就是整个流程。不过，在多条指令同时执行的情况下，仍然存在一些特定的问题，称为冒险问题。我们将在下一节中讨论这些冒险问题。下次见。


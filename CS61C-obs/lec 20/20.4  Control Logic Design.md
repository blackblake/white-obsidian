
在过去的几节课中，我们走过了几条指令的执行过程。有时，这个过程可能会让人觉得重复甚至无聊。但我们这样做有两个目的。第一个目的是弄清执行一条指令需要多长时间。实际上，我们已经测量了这一点，这将在下一模块中帮助我们。而第二个目的是让我们清楚地理解控制逻辑的作用，这将使接下来的内容更容易理解，并且看起来相对简单。  

---
### 控制逻辑概述


控制逻辑本质上可以被看作是一个查找表。这个查找表有许多行和列。行是输入，即我们想要执行的指令，列则是控制位，因此：
	**每一行的输入是我们正在运行的指令，外加两个额外的输入：它们是分支比较的结果，指示操作是否相等或小于。** 请记住，这些是控制逻辑作为输入的两支箭头，我们需要它们来选择某些控制信号。  

然后每一行都有一组设置好的控制信号，确保指令能够正确执行。  

那么，我们非常熟悉的一条指令是 add（加法）。add 指令的控制字编码在第一行中。我们可以将其视为一个字，它有大约 15 位。这意味着控制信号该是什么。我们知道，PCSel 信号应指向将获取下一条指令加上 4 的输入。立即数选择(ImmSel) 不重要，它可以是 0 或 1，或者说这是一个三位的值，所以可以是 000、001、010，等等，这对我们来说并不重要。  

同样，分支符号位也不重要，因为我们没有在执行分支操作。但是，ASel 和 BSel 信号是重要的，它们应该从寄存器中获取输入。ALU 是一个多位控制信号，因为 ALU 可以执行多种操作。在这个例子中，我们将其编码为执行加法，我们会设置它的控制位以进行加法运算。接着，内存读写信号将设置为读取，寄存器写使能信号将设置为 1，最后，写回选择是一个两位的控制信号，它将被设置为从 ALU 写回。  

---
### 实现控制逻辑


那么我们如何实现这个控制逻辑，即这个真值表呢？有两种方法。  

##### 1#  其中之一是使用只读存储器（ROM）：

只读存储器就像我们之前看到的标准存储器，只不过我们不往里面写数据，而是从里面读取数据。我们实际上是在设计时写入它的，在设计这个控制逻辑时，我们会将需要的 0 和 1 写入其中，因此实现起来相对容易。之后，我们只需通过指向我们想要从只读存储器中获取的特定控制字进行读取。  

设计者可以在设计期间不断重新编程它，然后通过执行一大堆指令来测试它。它非常简单，且在原型设计中很受欢迎。当我们想要扩展时，比如我们想要添加 RISC-V 指令集中的压缩部分时，也非常受欢迎。我们之前听说过压缩指令，所以我们只需要将查找表的这部分内容添加到我们的 ROM 中，然后进行尝试。  

##### 2#  另一种是使用组合控制逻辑，即由多个与（AND）和或（OR）门组成的逻辑。

实际上，当我们设计真正的芯片时，控制逻辑通常会被设计成多个与和或门组成的组合逻辑，因为这样更紧凑且更快。但是让我们看看我们需要什么来实现控制逻辑。我们需要什么样的输入？

我们需要 **为每条指令提供一个唯一的表示，此外还需要两个位用于分支结果。** 指令宽 32 位，但相关的信息仅存储在 9 位中。因此，有人可能会说这个 RISC-V 指令集实际上只需要 9 位。  

**\【PS】** 在 RISC-V 处理器的设计中，虽然每条指令都是 32 位宽的，但并不是所有的 32 位都用于确定指令类型。具体来说，只有 **9 位** 的信息能够唯一标识出指令的类型以及其他控制信息。这 9 位包括以下内容：
	1. **操作码的高 5 位**（Instruction's opcode upper 5 bits）：用于表示指令的主要类型（例如加法、减法、跳转等）。
	2. **功能码 3 字段（funct3）**（3 位）：用于进一步细化指令的种类。例如，操作码可能指示这是一个算术运算，但功能码 3 会告诉 ALU 是执行加法、减法还是其他运算。
	3. **功能码 7 字段的第 30 位（funct7 field's 30th bit）**（1 位）：这一位用于区分某些操作的特定变种，例如区分加法（add）和减法（sub），因为它们共享相同的操作码，但功能码 7 的第 30 位不同。`

因此，我们将**用一个 18 位宽的地址来指向 ROM，从中读取一个 15 位的控制字。这个控制字包含 1 位用于 PCSel，3 位用于立即数选择，1 位用于分支符号，1 位用于 ASel 和 BSel，ALU 选择将是一个 4 位的控制信号，内存读写是单个位，寄存器写使能信号也是单个位，最后，写回选择是 2 位输出。**

ROM 内部是如何工作的？它看起来就像一个查找表。我们将用相同的内容作为查找表的地址，即指令和分支结果作为输入。每一行将对应一个指令的控制字。**首先，我们解码地址。这些输入，即指令类型，都是二进制编码的。** 地址解码器的输出是所谓的一热编码（one-hot encoding），即只有一条线会被激活，我们只会访问一行控制字，因为这样才合适。我们不希望有两条不同的控制字输出，那会让数据通路混乱。对于每条指令或指令加分支组合，我们**只产生一个控制字**。  



---
### 举例

例如，当我们执行一条 add 指令时，它会指向 ROM 中的第一行。如果我们正在执行 add 指令，**只有这一行会被激活**，这个控制字将是唯一输出的控制字，其他行的**输出都是 0**。**控制器的输出就是与 add 指令对应的控制字**。
在某种意义上，你可以将其视为一个与/或结构。为了让这些行中只有一行被激活，地址解码器必须是一个相对宽的与门。而形成输出控制字的部分则可以通过或门实现，这是最简单的实现方式。总的来说，这里有很多冗余，许多条目会是 0，因此我们可以通过减少与门和或门的数量来简化整个控制逻辑。  

举个例子，最简单的编码例子之一可能是分支是否有符号。让我们看看如何编码一个分支。操作码的第 6 到第 2 位，表示这是一个分支操作，它们的值为 111 和 11000。然后我们需要查看 func3 字段，看看这是什么类型的分支。下面两个是无符号分支，分别是 BLTU 和 BGEU。它们和其他指令的区别在于功能 3 字段的中间位，即指令的第 13 位。这一位只有在无符号分支时才为真。因此，**解码分支的符号位控制信号实际上等于 func3 字段的第 13 位与分支信号的与：**
	- 如果当前执行的是分支指令（分支信号为 1），并且该分支指令要求进行有符号比较（功能 3 字段的第 13 位为 1），那么符号位控制信号就会为 1，表示需要进行有符号比较。
	- 如果当前不是分支指令（分支信号为 0），或者当前分支指令是无符号比较（功能 3 字段的第 13 位为 0），那么符号位控制信号就会为 0，表示不进行有符号比较。

`PS:分支信号是处理器控制逻辑的一部分，用于表示当前指令是否是分支指令。如果当前指令是分支指令，则分支信号为 1，否则为 0。`

至于如何解码分支，分支由指令的低位编码。分支的编码是指令的第 6 位和第 5 位为 1，而第 4 位、第 3 位和第 2 位为 0。这就是我们的分支，它解码了所有分支指令。**要选择无符号分支，我们只需将这5位与指令的第 13 位一起相与**，整个解码过程非常简单。这个与门是 6 位宽的。  

```
[6位宽的与门]

- 与门:只有当所有输入信号都为1时，输出才为1。
- 这里提到的 6位宽的与门，意味着需要对6位输入进行and运算。
- 具体来说，这6位是：
    - 指令的第 6 位、第 5 位、第 4 位、第 3 位、第 2 位（用来判断是否为分支指令）；
    - 以及 func3 字段的第 13 位（用来判断是否为无符号分支）。

通过这个 6 位宽的与门，处理器能够有效地识别出无符号分支指令。
```

请记住，6 位宽的与门在实际实现中可能并不总是最实用的，因此我们通常会将其分解为多个较小的门。布尔逻辑的简化就是为了这个目的，不是吗？它旨在帮助我们解码加法指令。所以加法指令就是这个真值表中的一行，它包含 9 位。  

这就是我们的加法指令。我们解码正在执行加法指令的方式很简单：它等于第 30 位为假，第 14 位为假，第 13 位为假，第 12 位为假。它们全为 0。接着，我们需要将它的与 R 类型指令相与。R 类型指令的编码为：第 6 位为假，第 5 位为真，第 4 位为真，第 3 位为假，第 2 位为假，所以我们将所解码的指令的6、5、4、3、2位与R指令的要求“00110”相与，即可判断其是否为R型指令。如果我们添加其他扩展，我们还需要与最低的两个位相与为 11，但在我们的项目中，我们不需要，因为我们没有其他指令。  

---
### GPT的例子

假设我们有一个指令 `instruction`，我们要检查它是否是加法指令。加法指令的解码条件是第 30 位、第 14 位、第 13 位和第 12 位都为 0。

我们还需要确认它是否符合 R 类型指令的特征。R 类型指令的特征是第 6 位为 0，第 5 位为 1，第 4 位为 1，第 3 位为 0，第 2 位为 0。

假设有一条指令，其二进制表示如下：

`11010000000000000001000100000000`

我们将其分成若干部分进行解码。

1. **检查加法指令条件**：
    
    - **第 30 位**：`1`（加法指令条件要求为 `0`，因此不满足）
    - **第 14 位**：`0`（满足条件）
    - **第 13 位**：`0`（满足条件）
    - **第 12 位**：`0`（满足条件）
    
    由于第 30 位不为 `0`，所以这条指令不满足加法指令的解码条件。因此，我们可以确定这条指令不是加法指令。
    
    `PS:处理器判断指令的某一位为0或1的方法是使用 [掩码]
    `例如，如果掩码值是 `00000000000000000000000001000000`，则逻辑与操作可以将指令的第 30 位提取出来。然后处理器检查提取出来的位是否满足条件。例如，若提取出来的值是 1，而要求是 0，则该条件不满足。`
    
2. **检查 R 类型指令条件**：
    
    对于 R 类型指令的特征条件：
    
    - **第 6 位**：`0`
    - **第 5 位**：`1`
    - **第 4 位**：`1`
    - **第 3 位**：`0`
    - **第 2 位**：`0`
    
    从指令中提取相关位：
    `01001 (这对应于第 6 到第 2 位)`
    与 R 类型指令的条件相与：
    `01001 AND 00110(R 类型指令条件)=00000`
    
    在这个例子中，`AND` 结果是 `00000`，说明这条指令不符合 R 类型指令的特征条件。

我们已经设计了一个可配置的数据路径，并概述了控制逻辑，这些逻辑设置数据路径以执行我们在 RV32I 指令集中所包含的几乎每一条指令。在这个过程中，我们发现数据路径和逻辑中有很多操作是并行发生的。例如，在我们从寄存器文件中检索操作数的同时，我们还在生成立即数。这些操作是并发进行的。

我们对时序有了初步的了解。时序非常重要。显然，这些实现数据路径和控制的逻辑需要一些时间才能完成。这个关键路径——执行数据路径中指令所需的最长时间——决定了我们可以以多快的频率围绕时钟操作这个处理器，以及我们每秒可以执行多少条指令。到目前为止，我们只有定性的时序感知，因此我们将尝试使其更加定量化。

为了做到这一点，我们来检查一下我们之前熟悉的数据路径。这是之前看到的相同图示，以及下面的控制模块。我们将执行一条非常熟悉的指令，即寄存器间的加法指令。这条指令像之前我们已经看到的每一条指令一样，在时钟的上升沿开始执行，那时我们更新程序计数器（PC）。程序计数器的新值会出现在其输出端。在这时，**有两个操作会并发进行：我们加 4 到 PC 的值，并从指令内存中提取指令。** 这两个过程所需的时间大致相当（虽然不完全相同，这取决于我们实现的技术）。因此，我们会有一个新的 PC+4 值准备好在这个多路选择器的输入端。然而，直到 PC 的值稳定下来，我们才能在 PC 上看到正确的值。

同时，我们将从指令内存中提取指令。当这些信号出现时，我们就完成了执行的第一阶段——指令提取。此时，另两个操作将并行进行：我们将开始从寄存器文件中检索源寄存器 rs1 和 rs2 的值，并开始解码指令。在解码指令的过程中，我们会发现这是一个加法指令。这条加法指令会告诉我们设置 PCSel 以选择这个多路选择器的顶部输入，即立即数选择控制应该是“无所谓”，因为该指令没有立即数。寄存器写使能应该设置为 1，因为我们需要将加法结果写回到寄存器文件的目标寄存器。所有分支信号都是“无所谓”，A 选择和 B 选择都设置为零，因为我们选择的是寄存器文件的输出。当选择设为加法时，内存写入设为读取，因为我们不对内存进行写入，并且写回选择设为 1，以便我们将结果写回到寄存器文件中。 

一旦信号 PCSel 稳定，我们将有一个有效的多路选择器输出值出现在程序计数器的输入端。然而，直到完成周期并设置下一个时钟的上升沿，这个新的值才会写入到程序计数器中。你会看到，这条路径比并行进行的路径要短得多。并行进行的路径包含了更多的模块，让我们来看一下下游发生了什么。

我们仍然处于指令解码阶段。当我们从寄存器文件中获得有效的输出时，指令解码阶段就完成了。然后我们进入执行阶段。在这一阶段，我们会通过这两个多路选择器，这两个多路选择器的传播延迟是并行发生的，所以我们只需计入一次传播延迟。然后我们通过 ALU 延迟，完成执行阶段。因此，所有三个阶段都完成了。对于寄存器间的加法指令，没有内存访问阶段，所以我们直接进入写回阶段。写回阶段的路径上只有一个多路选择器。数据准备好写回到目标寄存器中，它会在下一个时钟的上升沿被写入。需要注意的是，输入到寄存器 RD 的数据必须在时钟的上升沿之前稳定，以满足建立时间的要求。因此，这个延迟也需要被考虑在内。

在下一个时钟的上升沿，我们将更新目标寄存器和程序计数器。让我们看看详细的时序图，描述了这个过程的更多细节，并描述了执行指令过程中发生的并发操作。这是我们之前看到的相同的数据路径，我们对信号和时序进行了标注。时钟信号具有高电平和低电平，每个时钟周期对应于一个时钟上升沿到下一个时钟上升沿的时间。图中显示了两个时钟周期来完成。这将显示程序计数器输出的内容。

在程序计数器的输出端，有一个 32 位的信号束。我们不会单独显示这 32 条线，而是使用之前介绍的简写符号来表示。我们会将它们表示为一个信号束，并关联一个十六进制值。在这种情况下，我们假设程序计数器的值为1000hex。

**程序计数器输出的值在传播延迟 t_clock_to_q 之后有效，所有 32 条输出同时生效。此时有两个操作同时进行：我们从内存中提取指令，同时更新程序计数器——将程序计数器加 4。**

` “t_clock-to-q” 表示触发器（或寄存器）从 [接收到时钟信号的上升沿] 到其 [输出稳定] 所需的时间。这一时间段是影响时序性能的一个关键因素。`

PC 加 4 的值在通过该路径的传播延迟后变得稳定并更新。但这里有一个重要的特殊之处：
	  前面提到，当我们在时钟的上升沿更新 PC 时，所有这些输出在`clock to output`延迟之后会 **同时变化** ，因为它们都经过相同型号的触发器。然而与之不同的是， PC+4 的输出 却不会同时显示出来。这是因为 加法的最低有效位会比更高有效位更早稳定。因此，我们会有多个这样的表示延迟的叉子（见ppt）。在图示中，我们总是展示最后的转换。因此，在**最高有效位**的传播延迟之后，PC+4 就是新值。

与此同时，我们继续进行指令获取。指令会出现在指令内存的输出端，并且也会有 32 位。在这里我们使用一种表示方法，将指令反汇编并发现它是一个add指令，我们在这里并不是展示 32 位的内容，我们把它展示为“add x1,x2,x3”。注意，这里的传播延迟与其他延迟相当。

` "clock-to-output delay"（时钟到输出延迟）描述了从时钟信号的上升沿到电路输出稳定所需的时间`

---
### 详细时序图

然后是控制逻辑：
	a. 当指令从内存中读取时 ，我们完成了执行的第一阶段，即指令提取。
	b. 然后进入下一阶段，即指令解码。Control Logic 运行并设置控制位。读取寄存器的值通常比这需要更长的时间。当这些输出稳定时，我们完成指令解码。
	c. 然后，我们执行 ALU 操作。在这个时间点上(见图中"x")，我们完成了指令执行阶段。
	d. 最后，我们准备将结果写回到寄存器文件中。ALU 与写回信号(wb)稳定之间有一个短暂的延迟，这对应于最后一个多路选择器的延迟。但需要记住的是，我们不能让下一个时钟的上升沿过早，否则我们会违反建立时间。因此，我们必须尊周在时钟上升沿之前的建立时间 TSU。因此，这个从写回信号的最后过渡不能在寄存器文件的建立时间之后发生。这样，我们才能将正确的值写入寄存器。

最后，注意**程序计数器和寄存器文件是在同一时间更新的**。这是时钟的上升沿之后的`t_clock-to-q`延迟。

![[Pasted image 20240911171645.png]]

`图中从左到右的四条长竖线，分别表示[时钟上升沿],[指令获取],[指令解码],[指令执行]的完成时刻`

- **Clock（时钟）**：顶部显示的是时钟信号，时钟边沿标记了电路中状态变化的时刻。
- **PC（程序计数器）**：在时钟边沿之后，程序计数器（PC）的值发生变化，叉号显示了PC值更新的时间点。
- **PC+4**：每次时钟信号触发后，PC的值增加4，叉号表示这个更新的时间点。
- **inst[31:0]**：表示从指令存储器（IMEM）中取出的指令，叉号显示了指令从存储器读取并进入到处理流水线的时刻。
- **Control logic（控制逻辑）**：叉号表示控制逻辑生成控制信号的时刻。
- **Reg[rs1] 和 Reg[rs2]**：表示从寄存器文件中读取寄存器数据的时刻，叉号标记了读取完成的时刻。
- **ALU（算术逻辑单元）**：叉号表示ALU完成操作并输出结果的时间点。
- **WB（写回阶段）**：叉号显示了计算结果写回寄存器文件的时间点。



接下来让我们看看是否可以定量化这个时序。我们所说的有两个事情是并发发生的。我们假设Control Logic所需的时间明显短于从寄存器文件中检索数据所需的时间。因此**有两个循环决定了时序**：
	**1#  一个是涉及从PC经过其他模块和多路选择器传播的延迟，并返回到程序计数器 (图中颜色较浅的环路)。 这条延迟路径等于 `PC的clock-to-output延迟+加法add时间+传播到MUX的时间` ，然后还要满足程序计数器的建立时间。
	2#  另一个部分显然更长。黄色路径中，我们经历了程序计数器的时钟延迟、指令内存的访问时间、寄存器文件的访问时间、多路选择器MUX、ALU 延迟、另一个MUX，然后我们再次必须满足建立时间，但不是程序计数器的建立时间，而是寄存器文件的建立时间。**

所以我们可以正确地将值写入寄存器 rd。比较这两个路径，结果显示，最大的延迟总是 tIMEM（指令内存的延迟）、tReg（寄存器访问的延迟）、tmux（多路选择器的延迟）、tALU（ALU 的延迟），再加上另一个 tmux。因此，这里的 **关键路径是执行路径，而不是程序计数器的更新路径。**


---
### lw Instruction (5 phases)

好，这条指令只有四个执行阶段。现在我们来看一个有[五个阶段]的指令，即加载字（load word），或称 lw。在这种情况下，它的工作方式与其他指令完全相同。时钟的上升沿触发时，我们更新程序计数器，新值会出现在程序计数器的输出端。接下来，我们会并行执行两个路径：更新程序计数器的值和提取新指令。然后，我们开始解码该指令。我们适当地设置控制位，PC+4 的 PCSel 应该设置为什么？立即数选择设置为 I 类型，因为加载指令的立即数是 I 类型。寄存器写使能设置为 1，因为我们要将从内存中检索到的结果写回。所有分支信号都设置为“无关”。A 选择设置为 0，取 rs1，B 选择设置为 1，取立即数。ALU 将这两个值相加。内存读写设置为读取，因为我们这次是从内存中读取数据。写回选择设置为 0，以便将内存输出写回到目标寄存器中。

我们继续执行这个指令。由于 PC+4 很早就准备好了，只要 PCSel 信号准备好，我们就会将值写入程序计数器。与此同时，另两个操作也会并行进行，并在我们解码指令时开始。首先，我们访问寄存器文件，并获取 rs2 和 rs1 的输出。与此同时，我们还会生成立即数。由于立即数生成依赖于指令的解码，因此我们需要知道这是 I 类型的立即数，以便生成正确的立即数。因此，这个延迟通常与从寄存器检索数据的延迟相当。接下来，其余的过程类似于我们之前看到的。这完成了指令提取和指令解码阶段。指令提取通过访问指令内存完成。指令解码阶段也完成了。然后进入执行阶段。当 ALU 输出有效时，地址指向内存，执行阶段完成。我们进入内存访问阶段。最后，我们将结果写回到目标寄存器。

现在，我们有三个可能的关键路径。一个是我们已经确定的较短的浅色路径。它肯定比另外两个路径要短。其他两个路径几乎是相同的，它们只是在**寄存器文件访问和立即数生成延迟之间有所不同**。在这两种情况下，我们经过指令内存，然后是立即数生成或寄存器文件，之后是一个多路选择器、ALU 数据内存和另一个多路选择器。我们还需要加上程序计数器的`t_clock-to-q` 延迟，这启动了指令，以及寄存器文件的建立时间，以便正确写回结果。当完成这些步骤后，我们可以将结果写回到寄存器，并更新程序计数器。


---
### lw的详细时序图

更概念化的时序展示了我们之前几张幻灯片中看到的内容。这显示了在一个时钟周期内发生的情况。**程序计数器被更新，指令提取完成了执行的第一阶段。这里所需的时间是指令提取所需的时间。然后，当寄存器文件的输出有效时，完成了指令解码阶段。ALU 的稳定输出完成了执行阶段。稳定的内存输出完成了内存访问阶段。** 写回阶段的逻辑很少，所以我们必须逐步处理这个逻辑，并确保在下一个时钟的上升沿之前满足写回的数据的建立时间。

![[Pasted image 20240911200024.png]]

**PS**
	指令解码的工作是由 [控制逻辑](Control Logic) 和 [立即数生成器](Imm Gen) 共同完成的:Control Logic负责从指令中提取操作码（opcode）并生成控制信号。这些控制信号将指导后续执行阶段应该如何操作，比如选择ALU操作类型，是否读取或写入寄存器，是否进行内存访问等; 此外，在解码阶段，如果指令包含立即数，Imm Gen会从指令中提取相应的位并生成立即数，用于后续的ALU操作或内存地址计算。

---
###  **Timing计算**

如果我们给出一些数字，假设指令提取需要 200 皮秒来从指令内存中获取结果，然后再花费 100 皮秒读取寄存器以完成指令解码。ALU 可能需要 200 皮秒完成执行阶段。数据内存可能需要 200 皮秒来获取数据并完成内存访问阶段。最后，写回阶段需要 100 皮秒，包括建立时间。因此，执行这条指令的总时间是 800 皮秒。

值得注意的是，并不是所有指令都经过每一个阶段。有些指令会更快完成，有些则会更慢。我们总是需要考虑最坏的情况。在这个例子中，最坏情况是加载字指令。加法指令只经历了四个阶段，如我们之前所见：指令提取、指令解码、ALU 执行和写回，因此只需 600 皮秒。分支相等指令只经历了三个阶段，等等。加载字指令是最长的，需要 800 皮秒。

我们可以以多快的频率进行时钟操作？最大时钟频率是 1.25 吉赫兹。需要注意的是，如果我们能够以某种方式时钟化这个数据路径，以便仅执行其中的一部分，我们可能能够以每个执行单元的最长延迟对应的频率运行，例如 5 吉赫兹。但我们不能这样做，因为我们不能仅执行某些指令而忽略其他指令，或者只执行加法而忽略其他操作。不过，我们会看到稍后如何从中受益。现在我们稍作休息，马上回来。
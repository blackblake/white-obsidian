
---

现在让我们来看看在代码运行通过流水线时可能遇到的第三类冒险——控制冒险。这些冒险与分支和跳转指令有关。我们将重点关注分支，因为跳转是一种更直接的控制冒险情况。分支是有条件的，直到较晚的时候我们才能知道分支是否会被执行。

---
[p8]
让我们来看一下分支的执行过程。我们首先取指，经过指令解码阶段，我们发现这是一条分支指令。此时，我们还从寄存器文件中获取了`t1`和`t0`的值。我们最早能确定分支是否会被执行、`t0`和`t1`的值是否相等的时间，是在执行阶段的末尾。如果我们有合适的硬件，这时我们可以更新程序计数器，将其指向标签处的地址，或者继续执行流中的下一条指令。

在这个例子中，我们的下一条指令是`sub`。在我们知道上一条指令是否为分支之前，`sub`指令已经进入了流水线。因此，***无论分支的结果如何，它都会被执行。接下来的指令`or`也是一样的情况，它也会被执行，而不管分支的结果如何。***

##### 但是，如果分支应该被执行，我们就应该将程序计数器更新到指向标签的地址，这两个指令就不应该被执行。

接下来的指令`xor`是没问题的。在那个时候，程序计数器已经被更新，并且我们知道分支是否被执行了。因此，这条指令没问题，所有跟随它的指令也是一样的。

**为了确保正确的执行，因为我们在取指后需要两个周期才能知道分支是否被执行，我们不应该执行接下来两条指令。因此，在每一条分支指令之后，我们必须在流水线中 [插入两个停顿周期(NOP)]。** 我们别无选择，因为我们不知道分支会发生什么情况，因此我们最好不要开始执行其他指令——


---
#####  让我们看看如何最小化这两个停顿周期的严重惩罚。

首先，这里有一个简单的观察：如果分支没有被执行，那么在分支之后顺序取到的指令是正确的，我们不需要取消它们，因此可以继续执行它们。但是，另一方面，如果分支被执行了，我们就需要刷新流水线。

因此，如果分支有50%的概率不会被执行，我们可以减少这一惩罚。然而，如果分支99%的时间都会被执行，这对我们就没有帮助了，因为99%的时间我们都不得不取消那些已经在流水线中的两条指令。

**让我们回顾一下如何取消这些指令。** 
	我们基本上是将这些正在执行的指令转换为NOP（空操作指令）。我们是如何做到的呢？就像我们处理加载指令一样，我们***改变这些指令的控制位，使得它们不改变处理器的状态。***

所以，如果我们在早期阶段发现分支被执行了，我们就去将`sub`指令转换为NOP。同样，我们也要对后面的`or`指令执行相同的操作。这两条指令都被转换为NOP，它们不会改变处理器的状态。

请记住，这里与我们之前在处理加载延迟冒险时的情况不同，我们不会重新执行这些指令，因为它们不应该在这个分支之后被执行。因此，在我们将它们转换为两个NOP之后，我们更新程序计数器，然后我们可以执行接下来的指令，这些指令可能位于代码的另一个部分，也就是标签处，那里可能会有一条`xor`指令。接下来的所有指令都会继续执行。

因此，分支的惩罚现在减少到只有当分支被执行时才会出现的惩罚。当分支被执行时，我们必须在流水线中插入这两个NOP。

那么，有没有办法减少这些分支惩罚呢？每一次被执行的分支都会花费我们代价，每次的代价正好是两个周期的执行时间。确实有办法。

***我们可以观察到，分支通常是“经常执行”或“很少执行”的。我们可以预测分支是否会被执行。

我们如何做到这一点呢？**分支的性质决定了我们通常使用它们来执行某种循环代码。我们已经看到，我们通常在某个代码块周围循环，比如在`while`或`for`循环中。因此，如果我们的`for`循环应该执行100次，分支只会被执行一次，剩下的99次不会被执行。如果我们能够正确预测这个分支很少被执行——只有1%的概率被执行——那么我们可以节省大部分的惩罚。** 我们可以将这个分支的惩罚减少到1%的两个停顿周期。因此，我们可以继续执行循环内部的代码，只有在我们的预测不正确时才偶尔取消它。

**现在，我们如何预测分支是否应该被执行呢？**
	**有一个[单比特预测器]，记录上一次分支是否被执行。** 这是一个相当不错的指示，能够预测下一次是否会被执行。**我们只需要保持一个位，表示这个分支上一次被执行了。**

当然，正如我提到的，有更复杂的分支预测器。如果你参加CS152课程，你将学习一些这些分支预测器。这些预测器已经得到了相当完善的调优，无论代码如何，它们的准确率都能达到90%以上。代码不一定是100次循环。

---

让我们来看看分支预测为我们做了什么。我们仍在执行这条分支相等指令。如果分支被执行，我们会预测它会被执行，并开始从标签处执行代码。我们立即将该标签加载到程序计数器中，并继续执行指令。但在完成这些指令之后，我们有机会检查我们的预测是否正确，并在预测不正确时进行纠正。

如果我们的预测是正确的，那一切都很好。如果预测不正确，我们就必须将那些已经执行的指令转换为NOP。就是这样。

---
### 【理解】

1. 也就是说，遇到分支指令，别管那么多，先赌一把，赌它不会跳转到label，直接将PC+4，执行下一条指令；

2. 但是，如果在执行过程中忽然发现，还真的要跳转，那就赶紧亡羊补牢，那么这时候就需要做两件事情，***第一，要阻止已经被取值了的 `PC+4` 地址指令继续在流水线中执行（即杀死现在的流水线）；第二，改变 `PC` 值为要跳转到的地址。***

3. 为了完成上述第一个问题，我们在流水线中加入一个[选择器] `IRSrc`，当上一条指令到译码阶段被解译为跳转指令时，该选择器便会***切换到一条空指令 `nop`*** ,并且 **在周期结束时利用一个额外的加法器将指令的一部分和现有的 `PC` 相加计算得到新的跳转地址交给 `PC`，从而完成第二点。** 
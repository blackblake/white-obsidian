### （壹） 指令含义

1. 一般来说，第一个寄存器操作数 都是用来保存结果的，如add、sub等算术指令，and、or、xor等逻辑运算指令，以及所有的移位指令如sll、srl：

```RISC-V
  add x5,x6,x7      #x5=x6+x7
```

2. 但在存储指令store中，第一个寄存器是作为被读取的一方

```RISC-V
  sd x5,40(x6)      #Memory[x6+40]=x5
```

3. 移位操作的辨识

```RISC-V
  sll x5,x6,x7      #逻辑左移 x5=x6<<x7
  srl                逻辑右移
  sra                算术右移
```
   `上面三个指令加上i就是无符号版本

4. 条件分支（有条件跳转）

```RISC-V
  beq x5,x6,100      #相等即跳转  if(x5==x6) go to PC+100
  bne                 不等即跳转（unequal）
  blt                 x5<x6跳转（little）
  bge                 x5≥x6跳转（greater or equal）
```

`1.注意这里的第三个操作数，即立即数100，并不是说跳转到地址为100的指令，而是PC+100！
`2.上面三个指令加上i就是无符号版本`


### （贰）操作数

1. 32位(bit)=1字(word)=4字节(byte)

2. 加载(load)和存储(store)指令的偏移量必须是8（或4，取决于机器）的倍数，如

```RISC-V
如果想取数组A的下标为2的元素：

ld  x9,2(x22)是错的
ld  x9,16(x22)才能取到A[2]
```

---
### 补码

1. 正数的补码等于其原码

2. 负数的补码=原码按位取反后+1

3. 负数的原码转换为10进制数时，不会把最高位的权算作负数；
   负数的补码转换为10进制时，最高位的权为负，**得到的10进制数值会恰好等于原码转换为的10进制数值** 。
```
例如-5的二进制数表示为0000 0101，取补后得到补码11111011，请自行验算:二者都能转换为-5
```
 
---
### （叁）指令格式

1.  所有RISC-V指令都是32位长
 
2.  RISC-V是小端法

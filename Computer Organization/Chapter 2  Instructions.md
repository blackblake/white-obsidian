## （壹） 指令含义

1. 一般来说，第一个寄存器操作数 都是用来保存结果的，如add、sub等算术指令，and、or、xor等逻辑运算指令，以及所有的移位指令如sll、srl：

```RISC-V
  add x5,x6,x7      #x5=x6+x7
```

2. 但在存储指令store中，第一个寄存器是作为被读取的一方

```RISC-V
  sd x5,40(x6)      #Memory[x6+40]=x5
```

3. 移位操作的辨识

```RISC-V
  sll x5,x6,x7      #逻辑左移 x5=x6<<x7
  srl                逻辑右移
  sra                算术右移
```
   `上面三个指令加上i就是无符号版本

4. 条件分支（有条件跳转）

```RISC-V
  beq x5,x6,100      #相等即跳转  if(x5==x6) go to PC+100
  bne                 不等即跳转（unequal）
  blt                 x5<x6跳转（little）
  bge                 x5≥x6跳转（greater or equal）
```

`1.注意这里的第三个操作数，即立即数100，并不是说跳转到地址为100的指令，而是PC+100！
`2.上面三个指令加上i就是无符号版本`

---
## （贰）操作数

1. 32位(bit)=1字(word)=4字节(byte)

2. 加载(load)和存储(store)指令的偏移量必须是8（或4，取决于机器）的倍数，如

```RISC-V
如果想取数组A的下标为2的元素：

ld  x9,2(x22)是错的
ld  x9,16(x22)才能取到A[2]
```

---
## 补码

1. 正数的补码等于其原码

2. 负数的补码=原码按位取反后+1

3. 负数的原码转换为10进制数时，不会把最高位的权算作负数；
   负数的补码转换为10进制时，最高位的权为负，**得到的10进制数值会恰好等于原码转换为的10进制数值** 。
```
例如-5的二进制数表示为0000 0101，取补后得到补码11111011，请自行验算:二者都能转换为-5
```
 
---
## （叁）指令格式

1.  所有RISC-V指令都是32位长
 
2.  RISC-V是小端法

3. ![[Pasted image 20241005112213.png]]

---
## （肆）逻辑操作

1. **slli**常用于乘法
	左移i位相当于乘以$2^i$ (尤其常见于计算数组元素地址)
2. **AND**常用于掩码

`ps:2.7.2 边界检查的简便方法是什么意思？

---
## （伍）过程

### 1. **寄存器**
	 x10~x17：传递参数/返回值
	 x1：返回地址寄存器
	 x2：栈指针
	x5～x7以及x28～x31：临时寄存器，在过程调用中不被 被调用者（被调用的过程）保存
	x8～x9以及x18～x27：保存寄存器，在过程调用中必须被保存。​（一旦使用，由被调用者保存并恢复）

### 2. **跳转指令**

![[Pasted image 20241013124744.png]]
`jalr中的rs1是个寄存器`

> [!Note] Jal vs. jalr
> (a) jalr 指令和jal指令都是跳转指令,不同的是jalr指令是**相对**跳转,它把**当前指令的地址加上一个相对偏移量**,然后跳到新的地址。而jal指令是**绝对**跳转,它直接跳到指定的地址。
> (b) jalr 指令常用于函数调用,它可以在返回时自动跳回调用函数的地址,而jal指令则更适用于跳到程序的不同部分。

比如，**函数返回return常用的指令是`jalr x0, 0(x1)`**：
-将rd写为x0，意为不会保存当前PC+4的地址作为返回地址（因为这里是当前函数结束了，要return，而不是要调用其他函数，所以不会跳转回当前指令，故不用保存）;
-而`0(x1)`意为跳转到x1中保存的地址值，即返回地址；

设想，如果函数return不使用`jalr x0, 0(x1)`，而改用`jal`指令，那么计算返回地址的绝对地址立即数值将是很麻烦的，所以return一般用jalr翻译;
### 3. **栈** 是**向下增长**的
	通过`减小`栈指针来将值`压栈`，通过`增大`栈指针来`弹栈`
指令中的地址是栈中项目所占的**下边沿**，如"0(sp)"指的是[sp+0,sp+4]这4个字节(32bit machine)
### 4. **嵌套过程**

**遇到问题**
	假设主程序调用过程A，参数为3，将值3存入寄存器x10然后使用jal x1，A。再假设过程A通过jal x1，B调用过程B，参数为7，也存入x10。由于A尚未结束任务，所以寄存器x10的使用存在冲突。同样在寄存器x1中的返回地址也存在冲突，因为它现在具有B的返回地址。

**解决方法**
	- 解决方法是将所有**必须保存**的寄存器**压栈**。
	- 调用者将所有调用后还需要的参数寄存器(x10～x17)或临时寄存器（x5～x7和x28～x31）压栈。
	- 被调用者**将返回地址寄存器x1和被调用者使用的保存寄存器（x8～x9和x18～x27）压栈**。调整栈指针sp以计算压栈寄存器的数量。
	- 返回时，**从内存中恢复寄存器**并重新调整栈指针。

**例题：**
```c
int fact (int n)
{
	if (n < 1) return (1);
		else return (n * fact(n − 1));
}
```

```RISC-V
fact: //函数开始的标签一定要有

//不管有没有嵌套调用，都要在函数的一开始将返回地址和参数入栈保存
addi sp, sp, -8 // adjust stack for 2 items
sw x1, 4(sp) // save the return address
sw x10, 0(sp) // save the argument n

//如果n≥1则跳转到L1
addi x5, x10, -1 // x5 = n - 1
bge x5, x0, L1 // if (n - 1) >= 0, go to L1

//如果n小于1，fact将1放入一个值寄存器中以返回1
addi x10, x0, 1 // return 1
addi sp, sp, 8 // 因为n<1的操作是直接返回1,不会嵌套调用其他函数,所以x1和n没有改变.故直接弹栈,不需要把x1和n加载回寄存器
jalr x0, 0(x1) // return to caller

如果n<1,那么到此,fact函数就结束了,但如果n≥1,则下面是剩余的操作

//如果n≥1
L1: 
addi x10, x10, -1 // n >= 1: argument gets (n − 1)
jal x1, fact // call fact with (n − 1)

addi x6, x10, 0 // return from jal: move result of fact
(n - 1) to x6:
lw x10, 0(sp) // restore argument n
lw x1, 4(sp) // restore the return address
addi sp, sp, 8 // adjust stack pointer to pop 2 items
//这里发生了嵌套调用,所以需要把返回地址x1和参数n原来在fact函数一开始被压栈保存的值恢复到x1和x10寄存器里，然后才能进行弹栈(对比第3段)

mul x10, x10, x6 // return n * fact (n − 1)
jalr x0, 0(x1) // return to the caller
```

**解释**
-如果在起初，调用fact函数的地址是a0，那么通过jal，把a0+4的地址存到x1中，记该地址为a1；
-然后在fact1（这里用factn表示第n次调用fact）的一开始，把x1也就是a1的值压栈；
-若n<1，fact1直接返回1，然后弹栈，不需要恢复x1的值（因为没变）；---若n≥1，递归调用了fact2，则fact2在一开始把返回地址a2=a1+4压栈，假设fact2直接返回1，则在fact2结束时，x1的值是a2。
-但fact2结束后，程序应该继续进行这一段fact1里的指令：
```RISC-V
addi x6, x10, 0 // return from jal: move result of fact
(n - 1) to x6:
lw x10, 0(sp) // restore argument n
lw x1, 4(sp) // restore the return address
addi sp, sp, 8 // adjust stack pointer to pop 2 items
```
这就把在fact1之初压栈保存的返回地址a1恢复到了x1寄存器中，使fact1能正确地返回。

![[Pasted image 20241013141823.png]]

## 5. 过程帧

**（1）引入**
- **栈**也可以用于存储过程的**局部变量**，但这些变量**不适用于寄存器**，例如局部数组或结构体；
- 栈中包含过程所**保存寄存器**和**局部变量**的段称为**过程帧**。
- FP(freame pointer)、SP(stack pointer)分别值的是帧指针、栈指针；
- **x8**也可以用于表示帧指针

![[Pasted image 20241013142529.png]]

（2）疑问：帧指针到底有什么用？
帧指针的方便性在于对过程中栈内变量的所有引用都具有相同的偏移；
但是，帧指针并不是必需的。RISC-V C编译器仅在改变了栈指针的过程中使用帧指针；
### 6. 堆(heap)

除了局部变量之外，程序还需要为静态变量和动态数据结构分配内存空间

![[Pasted image 20241013193912.png]]
其中：
 - Text：RISC-V机器代码，通常称为代码段
 - static data： 静态数据段，用于存放常量和其他静态变量
 - Dynamic data：由malloc和new分配的动态数据
 - 存放数组和链表这类数据结构的段通常称为堆(heap)，它放在内存中

### 7.寄存器约定

下图总结了RISC-V汇编语言的寄存器约定，可以看出大多数过程可以使用多达8个参数寄存器、12个保留寄存器和7个临时寄存器而无须进入内存。

![[Pasted image 20241013194714.png]]

但是，如果参数超过8个怎么办？
答：**前8个**参数在**寄存器x10到x17中**，其余参数放在**内存**中--帧指针的上方，可通过**帧指针寻址**。

---
**load指令是I型格式**

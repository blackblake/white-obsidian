
# Build DataPath  
#### (R-Type for E.g.)

### 1. R-Type

##### 1）PC 
![[Pasted image 20241023210922.png]]

##### **2）寄存器堆(register file)**
![[Pasted image 20241023211319.png]]

##### 以add x1, x2, x3为例：

  a) 由于R型指令有三个寄存器操作数x1,x2,x3，每条指令需要从寄存器堆中读出两个Data，再写入一个Data。
	  
  b)   为读出一个Data，需要一个输入指定要读的寄存器编号（注意 **输入的是寄存器的 [编号]**），以及一个从寄存器堆读出的输出（**输出的Read data1, Read data2和register1, register2 是[对应]的）**；
    为写入一个数据字，寄存器堆需要两个输入：一个输入指定要写的寄存器号，另一个提供要写入寄存器的数据；
	  
  c) Write操作由控制信号 **RegWrite** 控制，在写操作发生的时钟边沿，写控制信号必须是 **有效(asserted)** 的（这里的表述是 "RegWrite是有效的" 而非 "RegWrite为1" , 是因为有时题目可能会指定低电平0为有效的）；
	  
  d) 如图4-7所示，我们总共需要四个输入（三个寄存器编号和一个数据）和两个输出（两个读出的数据）​。输入的寄存器编号为 **5位宽** ，用于指定 $2^5=32$ 个寄存器中的一个；

`PS:→上划一道斜杠,代表位宽`


### 2. Load/Store
---
**以lw/sw x1 , offset(x2)为例：**

![[Pasted image 20241023214659.png]]

##### （1）数据存储单元
a) 必须输入Address，否则无法知道要对哪个地址的data进行读/写；
	
b) 是启用Read data从内存中读取数据，还是启用Write data向内存中写入data，取决于MemRead和MemWrite哪个有效(asserted)，但二者不可能同时有效；

##### （2）立即数生成器 (ImmGen)
ImmGen有一个32位指令的输入，如果是load, store或分支条件成立时的Branch分支指令，则它会 **将指令中的一个12位字段[符号扩展]为32位结果输出** 

### 3. Branch
---
**以beq x1, x2, offset为例：**
`PS:第三个操作数是偏移量offset,如果x1≠x2,就会跳转到"相对于分支指令所在地址的分支目标地址"`
**为实现beq指令，需将PC值与[符号扩展后的]指令偏移量offset相加以得到分支目标地址**

##### （1）**一些规定：**

• 指令系统体系结构规定了计算分支目标地址的 **基址** 是分支指令所在地址；
• 指令系统体系结构还说明了计算分支目标地址时，**将偏移量左移1位** 以表示半字为单位的偏移量，这样偏移量的有效范围就扩大到2倍；



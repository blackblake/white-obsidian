
# Float

##### 1. 科学计数法：小数点左边只能有1位数字
 
##### 2. 规格化：小数点左边没有0，即**小数点左边只能是一个1**
 **(1.xxxxxxxx)$_2$×2$^{yyyy}$**

##### 3. 尾数：(1.xxxxxxxx)$_2$中的"xxxxxxxx"
增加尾数的位数可以提高精度，增加指数位数的大小则可以增加数的表示范围

##### 4. RISC-V浮点数格式
- **float单精度**(32bit)：1位符号位(1表示负数)+**8**位指数(包括指数的符号位)+**23**位尾数；
	
- **double双精度**(64bit)：1+**11**+**52**
`思考：float和double能表示的小数的范围是多少?`
##### 5. 溢出
- 上溢：**正**指数太大而无法用指数字段表示
	
- 下溢：**负**指数太大而无法用指数字段表示

##### 6. **前导1：**
  为了表示更多的位，IEEE 754让**规格化**二进制数的前导1是隐含(implicit)的
这是因为规格化数的小数点左边一定是一个1，所以不必占用存储空间，直接在结果上加上这个1即可，尾数部分全部用来保存小数点右边的值

![[Pasted image 20241015201623.png]]

所以除了0之外所有规格数的形式：**(-1)$^S$×(1+尾数)×2$^E$**

![[Pasted image 20241015202459.png]]

例外：**0没有前导1**,IEEE 754通过**将所有的指数位都设置为0**来表示这是一个0，此时隐含的前导1就会消失

##### 7. **有效位数**=尾数位数+1(隐含的前导1)

##### 8.不同编码表示的意义 
![[Pasted image 20241015204216.png]]

解释：
- 当指数为0, 前导1就会消失, 小数点左边为0；此时若尾数为0, 则该数为0;
	
- 第二行同理, 整数部分为0；尾数非0，则该数为(0.xxxxxxxx)$_2$×2$^{yyyy}$，即非规格化数（有前导0）
	
- 第三行可知格式为(1.xxxxxxxx)$_2$×2$^{yyyy}$，是规格化数
	
- 第4-5行需要注意，是IEEE浮点标准对**异常**的表示

##### 9.IEEE 异常表示
(1)正/负无穷

(2)表示无效运算结果的符号Nan
	例如0/0或无穷减去无穷。NaN表示不是一个数，其目的是推迟程序中的一些测试和决定，等到方便的时候再进行

##### 10.IEEE 指数排列对排序的考虑
(1)对于浮点表示，尤其是进行排序操作时，最好能直接利用已有的整数比较硬件来处理，这就是**符号位处于最高位**的原因，这样一来就可以快速判定是小于0、大于0还是等于0；

(2)把**指数字段放在尾数之前**也简化了利用整数比较指令对浮点数的排序。因为只要两个数的指数部分符号相同，那么具有更大指数的数就一定更大。

(3)**不足:**

![[Pasted image 20241015205402.png]]
于是出现了移码表示法

##### 11.移码表示法
(1)**偏移值**
单精度的偏移值为**127**
双精度的指数偏移值为**1023**

如指数-1表示为-1+127$_{10}$，指数1表示为1+127$_{10}$

![[Pasted image 20241015205648.png]]
`思考：这个范围怎么算的？`

所以，带偏移值的指数意味着一个由浮点数表示的值实际上是：
**(-1)$^S$×(1+尾数)×2$^{(指数-偏移量)}$**

![[Pasted image 20241015210850.png]]
![[Pasted image 20241015210905.png]]
详细笔记见书p137


## 浮点数加法
---
### [浮点数的运算步骤](https://www.cnblogs.com/yilang/p/11277201.html "发布于 2019-07-31 18:39")

浮点数的加减运算一般由以下五个步骤完成：**对阶**、**尾数运算**、**规格化**、**舍入处理**、**溢出判断**

**一、对阶**

所谓对阶是指将两个进行运算的浮点数的阶码对齐的操作。对阶的目的是为使两个浮点数的尾数能够进行加减运算。因为，当进行M x·2Ex与M y·2Ey加减运算时，只有使两浮点数的指数值部分相同，才能将相同的指数值作为公因数提出来，然后进行尾数的加减运算。对阶的具体方法是：首先求出两浮点数阶码的差，即⊿E＝E x-E y，将小阶码加上⊿E，使之与大阶码相等，同时将小阶码对应的浮点数的尾数右移相应位数，以保证该浮点数的值不变。几点注意：

（1）对阶的原则是**小阶对大阶**，之所以这样做是因为若大阶对小阶，则尾数的数值部分的高位需移出，而小阶对大阶移出的是尾数的数值部分的低位，这样损失的精度更小。

（2）若**二者的指数相等**，说明两浮点数的阶码已经相同，无需再做对阶操作。

（3）采用补码表示的尾数右移时，符号位保持不变。

（4）由于尾数右移时是将最低位移出，会损失一定的精度，为减少误差，可先保留若干移出的位，供以后舍入处理用。

**二、尾数运算**

尾数运算就是进行完成对阶后的尾数相加减。这里采用的就是我们前面讲过的纯小数的定点数加减运算。

**三、结果规格化**

在机器中，为保证浮点数表示的唯一性，浮点数在机器中都是以规格化形式存储的。对于IEEE754标准的浮点数来说，就是尾数必须是1.M的形式。由于在进行上述两个定点小数的尾数相加减运算后，尾数有可能是非规格化形式，为此必须进行规格化操作。

规格化操作包括左规和右规两种情况。

左规操作：将尾数左移，同时阶码减值，直至尾数成为1.M的形式。例如，浮点数0.0011·25是非规格化的形式，需进行左规操作，将其尾数左移3位，同时阶码减3，就变成1.1100·22规格化形式了。

右规操作：将尾数右移1位，同时阶码增1，便成为规格化的形式了。要注意的是，右规操作只需将尾数右移一位即可，这种情况出现在尾数的最高位（小数点前一位）运算时出现了进位，使尾数成为10.xxxx或11.xxxx的形式。例如，10.0011·25右规一位后便成为1.00011·26的规格化形式了。

**四、 舍入处理**

浮点运算在对阶或右规时，尾数需要右移，被右移出去的位会被丢掉，从而造成运算结果精度的损失。为了减少这种精度损失，可以将一定位数的移出位先保留起来，称为保护位，在规格化后用于舍入处理。

IEEE754标准列出了四种可选的舍入处理方法：

（1）就近舍入（round to nearest）这是标准列出的默认舍入方式，其含义相当于我们日常所说的“四舍五入”。例如，对于32位单精度浮点数来说，若超出可保存的23位的多余位大于等于100…01，则多余位的值超过了最低可表示位值的一半，这种情况下，舍入的方法是在尾数的最低有效位上加1；若多余位小于等于011…11，则直接舍去；若多余位为100…00，此时再判断尾数的最低有效位的值，若为0则直接舍去，若为1则再加1。

（2）朝+∞舍入（round toward +∞）对正数来说，只要多余位不为全0，则向尾数最低有效位进1；对负数来说，则是简单地舍去。

（3）朝-∞舍入（round toward -∞）与朝+∞舍入方法正好相反，对正数来说，只是简单地舍去；对负数来说，只要多余位不为全0，则向尾数最低有效位进1。

（4）朝0舍入（round toward 0）

即简单地截断舍去，而不管多余位是什么值。这种方法实现简单，但容易形成累积误差，且舍入处理后的值总是向下偏差。

**五、 溢出判断**

与定点数运算不同的是，浮点数的溢出是以其运算结果的阶码的值是否产生溢出来判断的。若阶码的值超过了阶码所能表示的最大正数，则为上溢，进一步，若此时浮点数为正数，则为正上溢，记为+∞，若浮点数为负数，则为负上溢，记为-∞；若阶码的值超过了阶码所能表示的最小负数，则为下溢，进一步，若此时浮点数为正数，则为正下溢，若浮点数为负数，则为负下溢。正下溢和负下溢都作为0处理。

要注意的是，浮点数的表示范围和补码表示的定点数的表示范围是有所不同的，定点数的表示范围是连续的，而浮点数的表示范围可能是不连续的。

### E.g.
![[Pasted image 20241015221111.png]]
![[Pasted image 20241015221155.png]]

**一定要记得检查上溢和下溢！！检查的标准是：指数是否在1~254之间（这是正负规格数指数的合法范围）**（如果发生溢出，程序会被[例外]打断）

`详细笔记见书p139`
`用于浮点加法的ALU见书p141`


## 浮点乘法
---

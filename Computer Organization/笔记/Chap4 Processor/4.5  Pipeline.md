流水线概述
---
##### 1. **每条指令的执行需要一个时钟周期，而这个时钟周期是固定的，等于执行最慢(延迟最长)的指令的时间**：
	
![[Pasted image 20241217002903.png|500]]
	
譬如图中设计的一个时钟周期的时长为800ps，即ld指令的时长；执行beq指令时，虽然它本身只需要500ps，但也会消耗800ps；


##### 2. **指令的每个阶段(每个功能单元的操作)的执行时间也是固定的，等于延迟最长的阶段的时长**：

![[Pasted image 20241217003111.png|500]]
如图，Reg执行阶段消耗了200ps的时间(等于最长的ALU或Data access时间)，尽管它本身不需要这么久；


##### 3. **[使用]流水线的指令执行时间 = [不使用]流水线的指令执行时间 ÷ 流水线级数**
（加速比=流水线级数）
譬如：对于800ps的非流水线时钟周期，五级流水线会将其改善为800ps/5=160 ps

ps：流水线级数为k，即把一个指令划分成k个阶段

##### 4. 符号解释
 
 IF：取指令阶段（instruction memory）
 ID：译码/读寄存器阶段（寄存器堆）
 EX：执行阶段（ALU）
 MEM：访问存储器阶段（data memory）
 WB：写回阶段
 **==左写右读==**：左半边阴影表示写操作、右半边阴影表示读操作

![[Pasted image 20241217012923.png|500]]

##### 5.  **前递** —— 处理数据冒险的第1个方法
![[Pasted image 20241217013050.png|500]]

##### 6.  **停顿** —— 处理数据冒险的第2个方法
	
![[Pasted image 20241217013203.png|500]]
对于如图的指令，前递无法解决数据冒险，只能选择停顿+前递

##### 7. **重排指令顺序** —— 处理数据冒险的第3个方法

![[Pasted image 20241217013418.png|200]]   
![[Pasted image 20241217013451.png|120]]

##### 8. 控制冒险的解决方案
![[Pasted image 20241217022057.png|500]]

##### 9. 动态预测
- 动态硬件预测器 根据每个条件分支指令的行为进行预测；
	
- 实现方法是 保存每个条件分支是否发生跳转的历史记录，从而利用过去预测未来；
	
-  如果预测错误，必须 **从正确的分支地址处重新启动流水线**；

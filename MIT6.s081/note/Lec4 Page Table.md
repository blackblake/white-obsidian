
`本笔记不包含所有lec note，只解释其中难以理解的概念`
[lecture notes](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec04-page-tables-frans/4.3-ye-biao-page-table)

### PTE
---
页表中的一个页表项，指向的是一个“页”，而不是一个具体的“字节”地址（否则还要页表干什么？），“页帧“（简称为”页page“）是内存分配中的基本单位。

### offset
---
1. 虚拟地址virtual address的oddset位有12-bit，能够在 $2^{12}=4096$ 大小的地址空间内表示任意字节。而每一个“页帧”的大小就是4096字节，所以用12-bit的offset能完全索引页帧内的任意字节；
2. 页帧的起始地址通过virtual address的27-bit的“Index”位来索引；
3. 将offset加上页帧的起始地址，就可以得到物理内存地址。

### 页帧分配的方式
---
Q: 既然物理地址的offset部分是完全复制自虚拟地址的offset的，那是不是说明，地址映射的工作要做的其实只有分配“页帧”就好了，不必具体到字节到字节的映射？

A: 是的。


### 不同进程之间的隔离
---
Q: 我们从CPU到MMU之后到了内存，但是不同的进程之间的怎么区别？比如说Shell进程在地址0x1000存了一些数据，ls进程也在地址0x1000也存了一些数据，我们需要怎么将它们翻译成不同的物理内存地址。

A: SATP寄存器包含了需要使用的地址转换表的内存地址。所以ls有自己的地址转换表，cat也有自己的地址转换表。每个进程都有完全属于自己的地址转换表。

### 多级页表
---
page table最多会有2^27个条目（因为虚拟内存地址中的index长度为27），这是个非常大的数字。如果每个进程都使用这么大的page table，进程需要为page table消耗大量的内存，并且很快物理内存就会耗尽。

所以实际上，硬件并不是按照这里的方式来存储page table。实际中，page table是一个多级的结构：
![[截屏2025-03-17 08.42.48.png|300]]

### 层次化的3级page directory结构
---
如上所述，3级页表结构是一种层次化的内存映射机制，用于优化虚拟内存到物理内存的地址转换过程。这种结构包含三个级别：页目录指针表(PDPT)、页目录(PD)和页表(PT)。

#### 3级页表的基本结构

1. **页目录指针表(Page Directory Pointer Table, PDPT)** - 最高级
2. **页目录(Page Directory, PD)** - 中间级
3. **页表(Page Table, PT)** - 最低级

#### 虚拟地址的分解

在3级页表中，一个32位虚拟地址通常会被分解为：

```
| PDPTE 索引 (位 31-30) | PDE 索引 (位 29-21) | PTE 索引 (位 20-12) | 页内偏移 (位 11-0) |
```

对于64位系统，通常使用更多的位。

#### 地址转换过程示例

假设我们有一个32位虚拟地址：`0x89ABCDEF`，使用3级页表结构将其转换为物理地址。

##### 步骤1：分解虚拟地址

将地址 `0x89ABCDEF` 分解为各个部分（假设使用上述位数分配）：

- PDPTE 索引 = `0x2`（从位31-30提取）
- PDE 索引 = `0x125`（从位29-21提取）
- PTE 索引 = `0x17B`（从位20-12提取）
- 页内偏移 = `0xDEF`（从位11-0提取）

##### 步骤2：查找物理页帧

1. **访问PDPT**：
    
    - CR3寄存器指向PDPT的基址，假设为 `0x10000000`
    - 使用PDPTE索引(`0x2`)访问PDPT：`0x10000000 + 0x2 * 8 = 0x10000010`
    - 从该地址读取PDPTE值，假设为 `0x20000001`（最低位为1表示存在）
    - 物理地址 `0x20000000` 是页目录的基址
2. **访问页目录**：
    
    - 使用PDE索引(`0x125`)访问页目录：`0x20000000 + 0x125 * 8 = 0x20000928`
    - 从该地址读取PDE值，假设为 `0x30000001`（存在位为1）
    - 物理地址 `0x30000000` 是页表的基址
3. **访问页表**：
    
    - 使用PTE索引(`0x17B`)访问页表：`0x30000000 + 0x17B * 8 = 0x30000BD8`
    - 从该地址读取PTE值，假设为 `0x40000001`（存在位为1）
    - 物理地址 `0x40000000` 是目标页帧的基址

##### 步骤3：计算最终物理地址

- 物理页帧地址 = `0x40000000`（从PTE获取，清除标志位）
- 页内偏移 = `0xDEF`（直接从虚拟地址复制）
- 最终物理地址 = `0x40000000 + 0xDEF = 0x40000DEF`

#### 3级页表的优势——节省内存空间

在实际系统中，虚拟地址空间使用通常是高度稀疏的。程序往往只使用其可用虚拟地址空间的一小部分，且这些使用区域通常不连续。使用单一大页表时：
- 必须为整个虚拟地址空间分配页表项，无论是否使用
- 例如，在64位系统中，如果每个页表项占8字节，单一页表可能需要数百TB的存储空间

而多级页表利用了这种稀疏特性：
- 只为实际使用的虚拟地址区域创建下级页表
- 未使用的大块虚拟地址区域只需上级目录中的一个空指针表示


### TLB
---
如果你切换了page table，操作系统需要告诉处理器当前正在切换page table，处理器会清空TLB。因为本质上来说，如果你切换了page table，TLB中的缓存将不再有用，它们需要被清空，否则地址翻译可能会出错。所以操作系统知道TLB是存在的，但只会时不时的告诉操作系统，现在的TLB不能用了，因为要切换page table了。在RISC-V中，清空TLB的指令是`sfence_vm`。

### xv6中的页表隔离与内存访问
---
xv6采用了内核和用户进程分离的页表机制，这意味着：

1. **双重页表结构**：
    
    - 内核有自己的页表，映射内核空间的虚拟地址到物理地址
    - 每个用户进程有自己独立的页表，映射用户空间的虚拟地址到物理地址
2. **跨页表访问问题**：
    
    - 当用户程序通过系统调用传递一个指针（如指向sys_info结构体的指针）给内核时
    - 这个指针是用户空间的虚拟地址，在内核的页表中并不指向相同的物理位置
    - 内核不能直接解引用这个指针，因为它在内核的地址空间中可能是无效的或指向完全不同的内存
3. **walk函数的作用**：
    
    - walk函数允许内核遍历用户进程的页表
    - 通过这个函数，内核可以将用户空间的虚拟地址转换为物理地址
    - 一旦获得物理地址，内核就可以直接访问相应的内存位置
4. **copy_in和copy_out函数**：
    
    - 这些函数使用walk功能来实现内核和用户空间之间的数据传输
    - copy_in：将数据从用户空间复制到内核空间
    - copy_out：将数据从内核空间复制到用户空间

这种机制确保了内核可以安全地访问用户进程的内存，同时维护了两个地址空间的隔离。当系统调用需要处理用户提供的指针时，内核会使用用户进程的页表将其翻译成物理地址，然后访问对应的内存位置，而不是尝试直接在内核的地址空间中使用这个指针。

这是操作系统设计中的关键安全机制，防止了用户程序直接访问内核内存，同时允许内核在需要时访问用户内存。


### 4.5 Kernel Page Table
---
这一节是关于内核页表的，我还没太搞懂，多看看（当然其他节也要多回顾，毕竟笔记只写了一些难懂的点，主干知识还是在网站上）


### `kvminit`函数
---
1. **初始化内核页表**：
   ```c
   kernel_pagetable = (pagetable_t) kalloc();
   memset(kernel_pagetable, 0, PGSIZE);
   ```
   - 首先通过`kalloc()`分配一个页（通常是4KB）作为内核的顶级页表
   - 然后用`memset`将其清零初始化，PGSIZE是页大小常量

2. **映射UART寄存器**：
   ```c
   // uart registers
   kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);
   ```
   - 将UART0（串口控制器）的物理地址映射到相同的虚拟地址
   - `PTE_R | PTE_W`标志表示这块内存可读可写

3. **输出页表信息**：
   ```c
   vmprint(kernel_pagetable);
   ```
   - 打印当前页表的结构信息，用于调试目的

4. 接下来是一对相似的把硬件的虚拟地址映射到物理地址的`kvmmap`函数；

5. **最后再次打印页表信息**：
    ```c
    vmprint(kernel_pagetable);
    ```
    - 完成所有映射后再次打印页表结构，可以用来对比前后变化

功能总结：
- `kvminit`函数创建了内核的初始页表
- 它将各种硬件设备的内存映射区域（UART、VIRTIO、CLINT、PLIC）映射到内核虚拟地址空间
- 它将内核代码映射为只读可执行，将内核数据和剩余物理内存映射为可读写
- 它映射trampoline页到特定的高虚拟地址位置
- 通过这些映射，内核可以访问所需的所有内存区域和设备

这些映射构成了xv6操作系统运行的基础内存环境，是整个内存管理系统的起点。


### `kvmmap`函数
---

`kvmmap`函数的主要目的是在内核页表中创建从虚拟地址到物理地址的映射。这个函数通常在系统初始化阶段被调用，用来建立内核需要的各种内存映射。

```c
void kvmmap(uint64 va, uint64 pa, uint64 sz, int perm)
```

各参数的含义：

1. **va (uint64)**：
    - 虚拟地址(Virtual Address)的起始位置
    - 这是内核想要用来访问某段内存的地址
2. **pa (uint64)**：
    - 物理地址(Physical Address)的起始位置
    - 这是实际的硬件内存地址或设备地址
3. **sz (uint64)**：
    - 要映射的内存区域大小（以字节为单位）
    - 例如，PGSIZE（通常是4096字节，即4KB）表示映射一个页面
4. **perm (int)**：
    - 权限标志，定义对映射区域的访问权限
    - 通常是多个标志的组合，使用按位或运算符（|）连接
    - 常见的权限标志包括：
        - `PTE_R`：可读
        - `PTE_W`：可写
        - `PTE_X`：可执行
        - `PTE_U`：用户模式（此标志在内核页表映射中通常不使用）



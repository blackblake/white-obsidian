### **算法步骤**
1. **两两分组比较**  
   - 将 $n$ 个元素分为 $\frac{n}{2}$ 对。
   - 对每对元素进行一次比较，确定较大者和较小者。  
     **比较次数**：$\frac{n}{2}$ 次。

2. **在较大组中找最大值**  
   - 所有较大者组成一个大小为 $\frac{n}{2}$ 的数组。  
   - 通过线性扫描找到最大值。  
     **比较次数**：$\frac{n}{2} - 1$ 次。

3. **在较小组中找最小值**  
   - 所有较小者组成一个大小为 $\frac{n}{2}$ 的数组。  
   - 通过线性扫描找到最小值。  
     **比较次数**：$\frac{n}{2} - 1$ 次。

---

### **总比较次数**
$$
\frac{n}{2} \ (\text{分组比较}) + \left(\frac{n}{2} - 1\right) \ (\text{找最大}) + \left(\frac{n}{2} - 1\right) \ (\text{找最小}) = \frac{3n}{2} - 2
$$

---

### **示例验证**
- **当 $n = 8$**（元素为 $a, b, c, d, e, f, g, h$）：  
  1. 分组比较：  
     $(a, b), (c, d), (e, f), (g, h)$ → 4 次比较。  
  2. 找最大值：在 $\{ \max(a,b), \max(c,d), \max(e,f), \max(g,h) \}$ 中比较 3 次。  
  3. 找最小值：在 $\{ \min(a,b), \min(c,d), \min(e,f), \min(g,h) \}$ 中比较 3 次。  
  **总比较次数**：$4 + 3 + 3 = 10$，符合 $\frac{3 \times 8}{2} - 2 = 10$。

---

### **正确性分析**
- **比较次数的优化**：通过两两分组，每对仅需 1 次比较即可同时确定候选的较大值和较小值，避免了独立遍历找最大和最小值的冗余比较。  
- **适用条件**：$n$ 是 2 的幂，确保所有元素能完美分组，无剩余元素。  
- **理论下限**：比较次数的下限为 $\frac{3n}{2} - 2$，该算法达到了理论最优。

---

### **总结**
通过分组比较并分别处理较大组和较小组，该算法以 $\frac{3n}{2} - 2$ 次比较高效地找到最大值和最小值，完美满足题目要求。
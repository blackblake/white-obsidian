
1. **`if(vec[i]==stk.top())`为什么这一句报错了？** 

答：你遇到的报错是因为 `stk.top()` 方法的名字和结构体中的 `top` 成员变量重名了。在你的代码中，`top` 既是一个变量，也定义成了一个方法（取栈顶元素），这会引发命名冲突，编译器无法正确区分你是想调用变量 `top` 还是方法 `top()`。解决方法是把`top()`方法更名为`getop()`。

![[Pasted image 20240925230322.png]]
**vscode的蓝色方块代表数据成员，紫色代表函数成员** 

---

2. **输入处理(1)：输入1个0是退出内层循环，开始读取下一个N的输入；连续输入2个0是结束整个程序** 

本题的输入是这样的：
```cpp
5                      //元素个数N
1 2 3 4 5              //要判断合不合法的出栈顺序1
5 4 1 2 3              //要判断合不合法的出栈顺序2
0                      //表示对当前N带领的判断结束
6                      //新的N
6 5 4 3 2 1            //要判断合不合法的出栈顺序1
0                      //表示对当前N带领的判断结束
0                      //退出程序
```

```
```cpp
	int N;
    while(cin>>N&&N!=0){//输入元素个数N，若N不为0则开启内层循环
    	
    	int x;
	    while(cin>>x&&x!=0){...//如果内层while循环遇到的第一个元素x不是0，就进行内层循环；如果x是0，就退出内层while循环。

	...}//退出内层while循环后，再次进入外层while循环，输入新的N，若输入0，则退出程序
    
```

---

3. **输入处理(2)：读取到N之后，如何做到N个N个地分组读取数据，并且读到0就退出内层循环？**

```cpp
//同样地，我们采用“嵌套循环”！输入第一个元素后，如果不是0，就进入内循环读取剩下的N-1个元素

while(cin>>x&&x!=0){...//读1个数据
	
	qu.push(x);//但是要注意把刚才的x作为第一个元素进队！
	
	for(int i=1;i<=N;i++){...//读N-1个数据

//这样，等结束内循环，再次回到while循环的时候，就已经读取了N个数据，并处理好了这一组的yes or no判断；然后开始下一组N个数据的处理。

```

---

4. **模拟思路**

![[Pasted image 20240926003926.png]]

---
5. **MyCode**

```cpp

/*省略了stack结构体的定义*/

int main(){
    int N;

    while(cin>>N&&N!=0){//外层循环，用于在连续输入2个0的情况下退出程序
    	int x;

    while(cin>>x&&x!=0){//内层循环，用于在输入1个0的情况下退出由当前N带领的循环，读取新的N
		
		stack stk(N);
    	queue<int>qu;
        
        qu.push(x);//记得把刚才输入的用于判断内层循环是否结束的元素x作为第一个元素入队
        
        for(int i=1;i<N;i++){//读取剩下的N-1个元素，建队
        int e;
        cin>>e;
        qu.push(e);
    }

   //核心思想
    for(int i=1;i<=N;i++){
        stk.push(i);

        while (stk.gettop()==qu.front())
        {
           qu.pop();
           stk.pop();
        }
        
    }

    if(stk.top==-1){
        cout<<"Yes"<<endl;
    }
    else{
        cout<<"No"<<endl;
    }
    
    }cout<<endl;//内层循环
    
	}//外层循环
    
    

    return 0;}
```

---
6. **关于stack结构体的gettop( )函数** 

```cpp
char gettop(){
        if(top != -1){
            return data[top];
        } 
    }
```

如果只写出了"top!=-1"，即栈不为空的情况的处理方法，而不处理top\==-1，即栈空的方法，就会导致可能返回一个异常，所以应该添加为：

```cpp
char gettop(){
        if(top != -1){
            return data[top];
        } 
        
        else {
            return '\0'; // 当栈为空时返回空字符
        }
    }
```

---
7. **Vector的含参初始化与push_back( )不可同用

**`vector<char> vec1(N);` 与 `push_back` 的冲突**： 你初始化了一个大小为 `N` 的向量 `vec1` 和 `vec2`，但在之后使用 `push_back` 往 `vec1` 里添加元素时，`vec1` 的大小会超出预期。因为 `push_back` 是在已有的向量大小基础上添加元素，而不是直接替换现有元素。因此，应该直接通过下标赋值，而不是 `push_back`。

---
8. **异常处理**

**主循环中的 `while(stk.gettop()!=e)` 死循环**： 如果 `vec1` 中的所有元素都不等于 `vec2` 的某个 `e`，程序会进入死循环，因为 `gettop()` 始终不会等于 `e`。你应该检查是否 `j` 已经越界，即没有更多元素可以被推入栈中。
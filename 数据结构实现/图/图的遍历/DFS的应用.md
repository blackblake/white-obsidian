### 例1  求是否有路径
假设图G采用邻接表存储，设计一个算法判断顶点u到顶点v之间是否有路径。并对于以下有向图，判断从顶点0到顶点5、从顶点0到顶点2是否有路径。
![[Pasted image 20241129145125.png|200]]
![[Pasted image 20241129150325.png]]
与原本DFS算法唯一不同的两处用黄线标出了

**这个`if(HasPath1(G,w,v))`其实是把递归调用放到了if判断语句当中**

### 例2  求简单路径

假设图G采用邻接表存储，设计一个算法求顶点u到顶点v之间的一条简单路径（假设两顶点之间存在一条或多条简单路径）

![[Pasted image 20241129150814.png]]
多了一步“若当前顶点是目标终点时，输出path”而已

==**注意path是非引用传参**==
PS：在二叉树的求路径题目中，当时用的是string来存储path，也是非引用传参

### 例2变种

![[Pasted image 20241129151708.png]]

这个就和求二叉树的所有路径很相似了，都是非引用传参的path变量、引用传参的res变量

![[Pasted image 20241129152411.png]]

![[Pasted image 20241129152426.png|300]]

>【辨析】path为什么要是引用传参？
- 若path是**引用传参**，则**每一次递归调用对path添加的元素 都会被保存**；
	
- 而若path是**非引用传参**，那么：
1. 若走到"死胡同"了，需要回溯，则当回溯到上一层caller时，之前的callee对path的改动（即所添加的顶点）就消失了，这就叫“==**自动回退**==”；
2. 若走的路径是有效的，则随着层层递归，走到终点时，path含有的元素就是正确的路径；


### 例3  判断图是否包含简单回路

假设有向图G采用邻接表存储，设计一个算法，判断图中是否包含任何**简单回路**（简单回路≠简单路径）：注意若一个有向图只有两个顶点a和b，并且存在边<a，b>和<b，a>，则认为存在回路。

![[Pasted image 20241129154101.png|500]]

![[Pasted image 20241129154256.png|600]]
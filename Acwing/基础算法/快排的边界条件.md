##### 2 指针移动的判断不带等号
---
使用两个指针i和j分别指向要处理的区间的左右两侧，每次向中间移动。只要q[i] < x成立就说明i位置的数在左侧区间是合理的，所以i ++，直到q[i] >= x停下来。接下来去移动j，只要q[j] > x成立就说明j位置的数在右侧区间是合理的，所以j --，直到q[j] <= x停下来。

**这里考虑一个边界问题，为什么移动i和j指针的条件是q[i] < x和q[j] > x，而不是q[i] <= x和q[j] >= x？** 

因为如果选取的x是数组里最大的数，那么一直都满足q[i] <= x，所以i会一直++发生越界都不会停下来。同理，如果选取的x是数组里最小的数，那么一直都满足q[j] >= x，所以j会一直--发生越界都不会停下来。

反例数据：1 3 2

第一轮时选取的3是数组里最大的，所以在第一轮时i就会一直++发生越界。


#### 3 在交换前检查指针相对位置
---
当两个指针都停下来之后，这一对数都是错位的，所以把它们交换一下，交换完成之后q[i] < x并且q[j] > x，下一轮就可以让i和j（只要满足i < j）继续对向移动了。

这里考虑一个边界问题，试想q[i]和q[j]在i == j - 1时停下来做交换的场景，交换完成之后i和j会各自前进（i ++, j --）一步，形成i > j（具体是i == j + 1）的不合法局面，这时候就不应该做交换了，所以在swap之前需要再判断一次i < j。

反例数据：
3 1 2

说明：
交换完3和1后形成1 3 2的局面，i ++变成1指向元素3，j --变成0指向元素1，没有做检查指针相对位置的判断，又发生了一次交换，恢复成3 1 2的局面。

### 4 使用do-while而不是while循环
---
指针i和j初始化为数组两侧外一个元素，即i = l - 1，j = r + 1，然后在数组中使用do-while循环每次先进行一次指针的移动，再去看循环条件。

这里考虑一个边界问题，为什么不能让i = l和j = r然后使用while循环代替do-while循环？因为如果数组中存在重复的数字，那么某一轮可能存在i和j都指向重复的数字，并且划分数字x也是这个数字，那么while (q[i] < x)和while (q[j] > x)判断不成立不会进入，又因为q[i] = q[j] = x，交换它们之后这个局面仍然不会改变，所以要使用do-while循环，确保每次两个指针都至少会移动一步，以保证上一次交换的结果能被走掉。

反例数据：
2 1 2

说明：
在i指向2、j指向2并且x = 2的一次处理中，一直重复发生这两个2的交换。


#### 5 选取数组中间的数字作为划分值
---
与其选取左右两端的数作为划分值，不妨选取数组中间的数字。

这里考虑一个边界问题，如果数组已经是有序的了，那么选取数组开头或者结尾的数字就意味着每次将长度为n nn的数组划分成了长度为1 11和n − 1 n-1n−1的两段，这时候快速排序递归处理的子问题规模还是这么大，总的时间复杂度就达到了O(n^2)，为了避免这种情况，要选取数组中间的数字作为划分值。


#### 6 使用[l, j]作为区间左半边而不是[l, i]
---
在快排一轮的处理结束后，递归处理的两个子区间应该是[l, j]、[j + 1, r]而不是[l, i]、[i + 1, r]。

这里考虑一个边界问题，试想q[i]和q[j]在i == j - 1时停下来做交换的场景，交换完成之后i和j会各自前进（i ++, j --）一步，形成i > j（具体是i == j + 1）的不合法局面。在这个局面下，满足性质<= x的区间是[l, j]而不是[l, i]，因此划分的两个区间是[l, j]、[j + 1, r]。

反例数据：
3 1 2

说明：
第一轮时选取的x = 1，在3和1发生交换后，变成1 3 2；
i变成1，j变成0，满足性质<= 1的区间应当是[0, j = 0]即[1]，而不是[0, i = 1]即[1,3]。


#### while(i<j)不能是i<=j
---
假设有一个数组 `arr = [1, 2]`，初始化：
- i = l - 1 = 0 - 1 = -1
- j = r + 1 = 1 + 1 = 2
##### 第一轮 while 循环

假设我们选择 `arr[0]` 作为基准值（即 `pivot = 1`）。

1. **移动 `i`**：从左到右找到第一个大于等于 `pivot` 的元素。
    
    - 初始 `i = -1`，`arr[i]` 不在有效范围内。
    - `i` 增加到 `0`，此时 `arr[i] = 1`，满足条件（`1 >= 1`），停止移动。

2. **移动 `j`**：从右到左找到第一个小于等于 `pivot` 的元素。
    
    - 初始 `j = 2`，`arr[j]` 不在有效范围内。
    - `j` 减少到 `1`，此时 `arr[j] = 2`，不满足条件（`2 > 1`），继续移动。
    - `j` 减少到 `0`，此时 `arr[j] = 1`，满足条件（`1 <= 1`），停止移动。

此时，`i = 0`，`j = 0`。

##### 第二轮 while 循环

在第一轮结束后，我们的 `i` 和 `j` 都是 `0`。如果我们使用 `while(i <= j)` 作为循环条件：

- 由于 `i` 和 `j` 都是 `0`，条件 `i <= j` 为真，进入循环。
- 在循环中，`i` 会继续向右移动，`j` 也会继续向左移动，最终导致 `i` 增加到 `1`，`j` 减少到 `-1`。

此时，`i` 变成 `1`，`j` 变成 `-1`，这时就会造成无限循环（==为什么？==）
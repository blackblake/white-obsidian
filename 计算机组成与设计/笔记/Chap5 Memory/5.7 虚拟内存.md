## 5.7.1 页的存放与查找

![[Pasted image 20241130003009.png|500]]

在地址转换过程中，虚拟地址的 **Virtual Page Number (VPN)** 会通过页表映射到物理地址中的 **Physical Page Number (PPN)**；而 ==页内偏移 (**Page Offset**) 在映射过程中保持 **不变**==。

1. **页大小固定：** 
	   在图中，页大小为 $2^{12}$ 字节（4 KiB），因此虚拟地址和物理地址的**低 12 位（Page offset）** 直接用于指定 **页内偏移** ，这部分不会发生变化。
    
2. **虚拟地址到物理地址的映射：**
    - 虚拟地址是 48 位，其中高 36 位用于表示虚拟页号（VPN）。
    - 物理地址是 40 位，其中高 28 位用于表示物理页号（PPN）。
    
	- 地址映射时，**页号减少(从36变为38)的原因——物理内存限制**：
	    - 虚拟地址空间可能非常大，但实际物理内存通常有限。
	    - 页号减少意味着物理地址只需要足够的页号来覆盖实际物理内存的大小。
	
 3. **1-bit的有效位(valid bit)：**
	 如果该位为无效，则该页就**不在主存中**，发生一次**缺页失效**;
	 如果该位为有效，则该页在内存中，并且该项包含物理页号。
	
4. **页表寄存器(Page table register)：**
	 用于存储页表在**内存**中的**起始地址**
	
5. **大小**（记住内存是以字节byte为最低寻址单位的）
	 在该图中，页大小为$2^{12}$个**字节**，即4KiB；
	 虚拟地址空间为$2^{48}$**字节**，物理地址空间为$2^{40}$字节；
	 页表中的表项数为$2^{36}$个，（由\[47,12]这36位指定）;
	 

## Virtual Memory I

1. 虚拟内存营造出内存很大的假象，使得每个进程(process)认为它们拥有整个的内存
2. “页(page)”的工作集(working set)被存在主存，其他部分存储在磁盘(disk)
3. 保护各个程序之间不会互相侵犯
4. Big Picture

   ![[Pasted image 20241205190240.png|400]]

5. 用户进程process使用的是虚拟地址，内存使用的是物理地址
6. 内存管理器负责将虚拟地址映射到物理地址
   
7. **内存管理器的三大作用**
- 映射虚拟地址到物理地址
- 把各process的内存分开，每个进程得到的内存是private的，一个程序中的错误不会影响另一个
- 把memory交换到disk上 (Give illusion of larger memory by storing some content on disk)
  
8. 页一般是4KB的大小(4096-bytes)，需要12-bits的offset来定位到单个页中的每个字节($2^{12}=4096$)

9. 前20-bits用来定位到某个页，后12-bits用来定位到页中的某个字节
	   虚拟地址的图示↓
	   ![[Pasted image 20241205191651.png|450]]
   
10. 每个process的物理地址一般都是非连续的

11. 每个process都有自己的一个页表page table
    ![[Pasted image 20241205191943.png|500]]

12. 虚拟地址转换为物理地址时，后12-bits的offset保持不变，前面的页表编号的位数可能变多也可能变少
	![[Pasted image 20241205192125.png|300]]

13. 物理地址的计算：**页地址page address + offset (虚拟地址的后12bit)**

14. 给不同的process分配不同的页表，从而把它们映射到不同的内存位置，这保护了他们之间不相互打扰；
    但process之间的共享也是possible的：这通过给process分配相同的物理地址来实现；

15. 写保护 (valid bit)：1-bit的有效位防止了错写操作

16. 疑问：
    ![[Pasted image 20241205193322.png|100]]
    这是一个页表，那么一个“页”是否就是这个页表的一行/一个entry？
    答：是的，每个页表项对应一个**页表项（Page Table Entrie, PTE )**, 包含该页的**物理地址**、有效位等信息

17. 页表的存储
    - 如果把全部页表都存在内存中的话，load和store指令的每次执行就需要访问两次内存；
    - 所以把页表最**频繁使用**的一部分存在**cache**中；

18. **DRAM/Disk位** -- 指示内容是在主存(DRAM)还是磁盘(Disk)中

19. **缺页失效(page fault) -- 有两种情况**
- 内容不在主存DRAM而在磁盘Disk中时；(valid-bit无效，发生缺页失效)
- 内容在磁盘Disk中也不存在时；
  ![[Pasted image 20241205194516.png|500]]



20. 页错误 被当作exception来处理


21. “页表使用虚拟地址中的页号作为索引，找到相应的物理页号“
    - 虚拟地址virtual address分为两部分：页号和偏移量
	- 虚拟地址中的**虚拟页号**用作索引，查找页表中的相应条目(entry)。这个条目包含了与该虚拟页号对应的**物理页号**；
	- 如果有效位为有效，页表提供虚拟页号对应的物理页号(如内存中该页的首地址)。如果有效位为无效，那么该页就只存在磁盘上的某个指定的磁盘地址
	- 请记住**内存中的页和磁盘上的页大小相等**
	![[Pasted image 20241205213354.png|300]]


22.

![[Pasted image 20241205201023.png|500]]
- 页表寄存器 -- 表明页表在内存中的位置
	
- 一个页表项(page table entry)包含两部分：valid bit和 **物理页号**，后者和继承自虚拟地址的offset一起构成了物理地址；
	
- **虚拟**地址(virtual address)由 20-bit**虚拟页号**  和12-bit偏移量 组成
- **物理**地址(physical address) 由 **物理页号** 和 12-bit 偏移量 组成

- 该图中：
a) 页大小page size=$2^{12}$ bytes；
b) 一个页表中有$2^{36}$个页表项PTE（虚拟页号共36bit）
c) 虚拟地址空间大小为$2^{48}$ bytes（虚拟地址共48bit）、物理地址空间大小为$2^{40}$ bytes（物理地址共40bit）

## 5.7.2 缺页失效

1. 如果虚拟页的valid bit为无效，则发生缺页失效；
2. 发生缺页失效后，操作系统需要把缺的这个页**从磁盘加载到内存**中。所以它必须在磁盘中找到该页，并确定将请求的页放在主存中的什么位置；
3. 但若**内存已被全部占用**，所缺的页就无法被加载到内存中，这时就需要选择内存中的一页进行**交换**；
4. 由于我们无法提前获知存储器中的某一页什么时候将被替换出去，因此操作系统通常会在创建进程时为所有页面在闪存或磁盘上创建空间。这个空间被称为**交换区**；
5. **交换区的作用：**
	- 为被替换的页面提供临时存储
	- 保证被置换页面不会丢失
	- 方便后续需要时快速恢复

## Virtual Memory II

### 1）多级页表

1. 每个页表的大小=$4*2^{20}$=4MiB
	页表项大小=4Bytes (32-bit)
	每个页表有20个页表项 (虚拟地址的前20位)
当进程变多，这个大小会使内存难以承受，所以要采取一种更合理的页表管理方式
   
2.  多级页表的思想
	首先使用地址的最高几位查看0级页表中的地址，进行地址转换。如果页表中对应的表项有效，则使用下一组高位地址来索引第0级页表表项指示的页表，依此类推；
   
   3. 在内存中，栈乡下增长、堆向上增长，二者中间会存在一大块**未使用区域**；我们的第一级页表中的指针由于是对大块区域寻址，所以其中很多会**指向空的区域**，从而为页表节省大量空间；
	   ![[Pasted image 20241207214641.png|100]]

4. 多级页表示意图
	![[Pasted image 20241207221757.png|500]]

5. 多级页表的结构（32位机器中）
	32位虚拟地址被分成3部分：两个10-bit的虚拟页号、一个12-bit的页内偏移量
	![[Pasted image 20241207221617.png|500]]
	当页表后面所有那些R、W、X=0时就说明需要指向下一层页表了；否则则说明当前层就是叶子页表（即所要寻址的最终目的地）

### 2）TLB

1. TLB包含少量的近期被引用过的项，每一个项(或称为条目)都对应一个页page
2. 我们不是一开始就去内存中寻找内容，而是用虚拟页号VPN在TLB中匹配，如果找到匹配的项，就把物理页号从该项中提取出来，然后和虚拟地址中的offset结合以访问实际内存位置；如果不存在匹配项（TLB失效）则需要根据层次结构来遍历页表，并更新TLB；
3. TLB必须继承各个状态位，如valid bit, dirty bit等
	![[Pasted image 20241209193830.png|500]]

4. TLB一般具有32-128个项(entry)，并且通常采用 **全关联**
5. TLB采用 **FIFO替换策略**: 当TLB满时，把第一个写入的项替换出来，取而代之的是最新的项
6. **"TLB范围"** : 即TLB可以同时映射的最大虚拟地址空间的大小
	例如TLB中有64个项，每一项对应一个4KiB的页面，则TLB的范围=64\*4KiB=256KiB

7. 我们最先查看的一定是TLB而不是Cache，且cache接收的是物理地址physical address（如果TLB命中的话）
8. TLB进行虚拟地址到物理地址的转换（而不是页表）
	虚拟地址 → TLB → 物理地址 → Cache
	(如果TLB失效，则需要暂停cache访问；等待地址转换完成后，cache再接收物理地址)

9. CPU发送虚拟地址给TLB，TLB将虚拟地址转换为物理地址。
	a) 如果TLB命中，则在cache中访问这个物理地址的内容，如果cache中没有则去主存访问b) 如果TLB失效，则需要访问页表、更新TLB
	![[Pasted image 20241209193903.png|350]] 

10. TLB如何实现地址转换
    ![[Pasted image 20241209194210.png|500]]
a) 我们把虚拟页号VPN分成TLB Tag, TLB Index两部分，其中Index用来在TLB内部指向Tag（这是组相联的情况下）如果用全相联的话就不需要Index部分了，tag部分就把整个vpn复制过去，然后与TLB中的每一项进行比对，如果存在匹配项则命中；
b) 如果命中，我们把TLB中匹配的那一项的物理页号PPN提取出来，和虚拟地址中的offset结合，形成了虚拟地址；
c) 最后，把虚拟地址拆分成tag-index-offset的形式，就可以去cache中寻找内容了；


## 5.7.5 TLB

**1. 为什么要有TLB？**
	由于页表存储在主存中，因此程序每个访存请求至少需要两次访存：第一次访存获得物
 理地址，第二次访存获得数据；
 
 **2. TLB的通俗比喻**
    TLB就相当于记录目录中的一些书的位置的小纸片：我们在纸片上记录一些书的位置，并且将小纸片当成图书馆索书号的 cache, 这样就不用一直在整个目录中搜索了；

**3. TLB的每一个条目的构成**
	a) TLB中的每个标签项保存虚拟页号的一部分，每个数据项保存一个物理页号；
	b) 因为每次引用都访问TLB而不是页表，所以TLB需要包括其他状态位，如脏位等
	![[Pasted image 20241209200404.png|500]]

**4. 如果TLB发生失效**
 必须确定是缺页失效或只是TLB失效：
	 a) 如果该页在内存中，TLB失效表明缺少该地址转换。在这种情况下，处理器可以将(最后一级)页表中的地址转换加载到TLB中，并重新 访问来处理失效；
	 b) 如果是该页不在内存中，那么TLB失效意味着真正的缺页失效。在这种情况下，处理器调用操作系统的例外处理；
	c) 当替换某一TLB表项时，需要将其有效位、脏位等位复制回对应的页表项

**5. TLB使用写回策略**
	在失效时将这些表项写回而不是任何写操作都写回

6. 实现全相联的TLB要求将虚拟页号与每个TLB标签进行比较，因为需要的项可能在TLB中的任何位置；

7. 
![[Pasted image 20241209200950.png|500]]

8. 
![[Pasted image 20241209201141.png|500]]

**9. 写保护**
	a) 虚拟存储允许多个进程共享一个主存，同时为这些进程提供内存保护。保护机制必须确保：一个恶进程不能写另一个进程的地址空间；
	b) TLB中的写访问位可以防止一个页被写入；

**10. 处理 TLB失效和缺页失效**

**a）**  当发生TLB命中时，使用TLB将虚拟地址转换为物理地址很简单，但处理TLB失效和缺页失效却很复杂；

**b）** TLB失效表明两种可能：
	1.页在内存中，只需创建缺少的TLB表项。
	2.页不在内存中，需要将控制转移给操作系统来处理缺页失效。

**c）** 处理TLB失效或缺页失效需要使用例外机制来中断活跃进程，将控制转移到操作系统，再恢复执行被中断的进程；操作系统必须完成以下三个步骤：
1. 使用虚拟地址找到对应的页表**表项**，并在辅助存储如disk中找到引用页的位置。
	
2. 选择要**替换**的物理页；如果所选页是脏的，则必须先将其写入辅助内存以防丢失，然后才能将新的虚拟页写到此物理页中。
	
3. 启动**读操作**，将被访问的页从磁盘上取回到所选择的物理页的位置上

**d）** 为了在缺页失效处理结束后重启指令，必须保存导致缺页失效的指令的程序计数器PC。

**e）** TLB失效或缺页失效例外必须在访存发生的同一个时钟周期的末尾被判定，这样下一个时钟周期将开始进行例外处理而不是继续正常的指令执行。
